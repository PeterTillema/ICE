; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"..\SRC\ROUTINES.C"
	.assume ADL=1
	SEGMENT CODE
;    1	#include "defines.h"
;    2	#include "main.h"
;    3	#include "routines.h"
;    4	
;    5	#include "ast.h"
;    6	#include "functions.h"
;    7	#include "errors.h"
;    8	#include "stack.h"
;    9	#include "parse.h"
;   10	#include "output.h"
;   11	#include "operator.h"
;   12	
;   13	#define LB_X 80
;   14	#define LB_Y 210
;   15	#define LB_W 160
;   16	#define LB_H 10
;   17	
;   18	extern prescan_t prescan;
;   19	extern const uint8_t implementedFunctions[AMOUNT_OF_FUNCTIONS][5];
;   20	
;   21	uint8_t GetIndexOfFunction(uint8_t tok1, uint8_t tok2) {
_GetIndexOfFunction:
	LD	HL,-4
	CALL	__frameset
;   22	    uint8_t a;
;   23	    
;   24	    if (!IsA2ByteTok(tok1)) {
	LD	C,(IX+6)
	LD	B,0
	PUSH	BC
	CALL	_IsA2ByteTok
	POP	BC
	OR	A,A
	JR	NZ,L_7
;   25	        tok2 = 0;
	LD	(IX+9),0
;   26	    }
L_7:
;   27	    
;   28	    for (a = 0; a < AMOUNT_OF_FUNCTIONS; a++) {
	LD	(IX+-1),0
	JR	L_6
L_4:
;   29	        if (implementedFunctions[a][0] == tok1 && implementedFunctions[a][1] == tok2) {
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	A,5
	CALL	__imul_b
	LD	BC,_implementedFunctions
	ADD	HL,BC
	LD	(IX+-4),HL
	LD	A,(HL)
	CP	A,(IX+6)
	JR	NZ,L_5
	LD	HL,(IX+-4)
	INC	HL
	LD	A,(HL)
	CP	A,(IX+9)
	JR	NZ,L_5
;   30	            return a;
	LD	A,(IX+-1)
	JR	L_9
;   31	        }
;   32	    }
L_5:
	INC	(IX+-1)
L_6:
	LD	A,(IX+-1)
	CP	A,33
	JR	C,L_4
;   33	    
;   34	    return -1;
	LD	A,255
;   35	}
L_9:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _GetIndexOfFunction ***************************
;Name                         Addr/Register   Size   Type
;_implementedFunctions               IMPORT    165   variable
;_IsA2ByteTok                        IMPORT  -----   function
;G_0                                   IX-4      3   variable
;a                                     IX-1      1   variable
;tok2                                  IX+9      1   parameter
;tok1                                  IX+6      1   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


;   36	
;   37	void OutputWriteByte(uint8_t byte) {
_OutputWriteByte:
	LD	HL,-3
	CALL	__frameset
;   38	    *ice.programPtr++ = byte;
	LD	BC,(_ice+60)
	LD	(IX+-3),BC
	LD	HL,BC
	LD	A,(IX+6)
	LD	(HL),A
	LD	BC,(_ice+60)
	INC	BC
	LD	(_ice+60),BC
;   39	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _OutputWriteByte ***************************
;Name                         Addr/Register   Size   Type
;_ice                                IMPORT  10958   variable
;byte                                  IX+6      1   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;   40	
;   41	void OutputWriteWord(uint16_t val) {
_OutputWriteWord:
	CALL	__frameset0
;   42	#ifdef CALCULATOR
;   43	    *(uint16_t *)ice.programPtr = val;
	LD	HL,(_ice+60)
	LD	A,(IX+6)
	LD	(HL),A
	INC	HL
	LD	A,(IX+7)
	LD	(HL),A
;   44	#else
;   45	    w16(ice.programPtr, val);
;   46	#endif
;   47	    ice.programPtr += 2;
	LD	IY,(_ice+60)
	LEA	BC,IY+2
	LD	(_ice+60),BC
;   48	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _OutputWriteWord ***************************
;Name                         Addr/Register   Size   Type
;_ice                                IMPORT  10958   variable
;val                                   IX+6      2   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;   49	
;   50	void OutputWriteLong(uint24_t val) {
_OutputWriteLong:
	CALL	__frameset0
;   51	#ifdef CALCULATOR
;   52	    *(uint24_t *)ice.programPtr = val;
	LD	HL,(_ice+60)
	LD	BC,(IX+6)
	LD	(HL),BC
;   53	#else
;   54	    w24(ice.programPtr, val);
;   55	 #endif
;   56	    ice.programPtr += 3;
	LD	IY,(_ice+60)
	LEA	BC,IY+3
	LD	(_ice+60),BC
;   57	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _OutputWriteLong ***************************
;Name                         Addr/Register   Size   Type
;_ice                                IMPORT  10958   variable
;val                                   IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;   58	
;   59	void OutputWriteMem(uint8_t mem[]) {
_OutputWriteMem:
	LD	HL,-3
	CALL	__frameset
;   60	    uint24_t size = strlen((char*)mem);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strlen
	POP	BC
	LD	(IX+-3),HL
;   61	    
;   62	    memcpy(ice.programPtr, mem, size);
	LD	BC,HL
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	LD	BC,(_ice+60)
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;   63	    ice.programPtr += size;
	LD	BC,(IX+-3)
	LD	HL,(_ice+60)
	ADD	HL,BC
	LD	(_ice+60),HL
;   64	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _OutputWriteMem ***************************
;Name                         Addr/Register   Size   Type
;_ice                                IMPORT  10958   variable
;_memcpy                             IMPORT  -----   function
;_strlen                             IMPORT  -----   function
;size                                  IX-3      3   variable
;mem                                   IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;   65	
;   66	bool IsA2ByteTok(uint8_t tok) {
_IsA2ByteTok:
	LD	HL,-12
	CALL	__frameset
;   67	    uint8_t All2ByteTokens[9] = {tExtTok, tVarMat, tVarLst, tVarPict, tVarGDB, tVarOut, tVarSys, tVarStrng, t2ByteTok};
	LEA	DE,IX+-12
	LD	HL,_0temp15
	LD	BC,9
	LDIR	
;   68	    
;   69	    return memchr(All2ByteTokens, tok, sizeof(All2ByteTokens)) || 0;
	LD	BC,9
	PUSH	BC
	LD	A,(IX+6)
	UEXT	HL
	LD	L,A
	PUSH	HL
	PEA	IX+-12
	CALL	_memchr
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	Z,L_18
;   70	}
	LD	BC,1
	LD	(IX+-3),BC
	JR	L_19
L_18:
	LD	BC,0
	LD	(IX+-3),BC
L_19:
	LD	A,(IX+-3)
	LD	SP,IX
	POP	IX
	RET	


;**************************** _IsA2ByteTok ***************************
;Name                         Addr/Register   Size   Type
;_memchr                             IMPORT  -----   function
;_0temp15                            STATIC      9   variable
;All2ByteTokens                       IX-12      9   variable
;temp20                                IX-3      3   variable
;tok                                   IX+6      1   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT TEXT
_0temp15:
	DB	239
	DB	92
	DB	93
	DB	96
	DB	97
	DB	98
	DB	99
	DB	170
	DB	187
	SEGMENT CODE
;   71	
;   72	prog_t *GetProgramName(void) {
_GetProgramName:
	LD	HL,-7
	CALL	__frameset
;   73	    prog_t *ret;
;   74	    uint8_t a = 0;
	LD	(IX+-1),0
;   75	    int token;
;   76	    
;   77	    ret = (prog_t*)malloc(sizeof(prog_t));
	LD	BC,10
	PUSH	BC
	CALL	_malloc
	POP	BC
	LD	(IX+-4),HL
;   78	    ret->errorCode = VALID;
	LD	IY,(IX+-4)
	LD	(IY+0),255
;   79	
;   80	    while ((token = _getc()) != EOF && (uint8_t)token != tEnter && (uint8_t)token != tRParen) {
	JR	L_27
L_28:
;   81	        if (a == 8) {
	LD	A,(IX+-1)
	CP	A,8
	JR	NZ,L_26
;   82	            ret->errorCode = E_INVALID_PROG;
	LD	IY,(IX+-4)
	LD	(IY+0),14
;   83	            return ret;
	LD	HL,(IX+-4)
	JR	L_32
;   84	        }
L_26:
;   85	        ret->prog[a++] = (uint8_t)token;
	LD	D,(IX+-7)
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	IY,(IX+-4)
	LEA	HL,IY+1
	ADD	HL,BC
	LD	(HL),D
	INC	(IX+-1)
;   86	    }
L_27:
	CALL	_getNextToken
	LD	(IX+-7),HL
	LD	BC,16777215
	OR	A,A
	SBC	HL,BC
	JR	Z,L_30
	LD	A,(IX+-7)
	CP	A,63
	JR	Z,L_30
	LD	A,(IX+-7)
	CP	A,17
	JR	NZ,L_28
L_30:
;   87	    if (!a) {
	LD	A,(IX+-1)
	OR	A,A
	JR	NZ,L_31
;   88	        ret->errorCode = E_INVALID_PROG;
	LD	IY,(IX+-4)
	LD	(IY+0),14
;   89	    }
L_31:
;   90	    
;   91	    ret->prog[a] = 0;
	LD	A,(IX+-1)
	UEXT	HL
	LD	IY,(IX+-4)
	LD	L,A
	LD	BC,HL
	LEA	HL,IY+1
	ADD	HL,BC
	LD	(HL),0
;   92	
;   93	    return ret;
	LD	HL,(IX+-4)
;   94	}
L_32:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _GetProgramName ***************************
;Name                         Addr/Register   Size   Type
;_getNextToken                       IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;token                                 IX-7      3   variable
;ret                                   IX-4      3   variable
;a                                     IX-1      1   variable


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


;   95	
;   96	void ProgramPtrToOffsetStack(void) {
_ProgramPtrToOffsetStack:
;   97	    ice.dataOffsetStack[ice.dataOffsetElements++] = (uint24_t*)(ice.programPtr + 1);
	LD	BC,(_ice+3077)
	LD	DE,(_ice+60)
	LD	HL,3
	CALL	__imulu
	INC	DE
	LD	BC,_ice+77
	ADD	HL,BC
	LD	(HL),DE
	LD	BC,(_ice+3077)
	INC	BC
	LD	(_ice+3077),BC
;   98	    reg.allowedToOptimize = false;
	XOR	A,A
	LD	(_reg+9),A
;   99	}
	RET	


;**************************** _ProgramPtrToOffsetStack ***************************
;Name                         Addr/Register   Size   Type
;_reg                                IMPORT     28   variable
;_ice                                IMPORT  10958   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  100	
;  101	void AnsToHL(void) {
_AnsToHL:
;  102	    MaybeAToHL();
	CALL	_MaybeAToHL
;  103	    if (expr.outputRegister == REGISTER_DE) {
	LD	A,(_expr+10)
	CP	A,1
	JR	NZ,L_38
;  104	        EX_DE_HL();
	LD	BC,235
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	CALL	_RegChangeHLDE
;  105	    }
L_38:
;  106	    expr.outputRegister = REGISTER_HL;
	XOR	A,A
	LD	(_expr+10),A
;  107	}
	RET	


;**************************** _AnsToHL ***************************
;Name                         Addr/Register   Size   Type
;_RegChangeHLDE                      IMPORT  -----   function
;_OutputWriteByte                    IMPORT  -----   function
;_expr                               IMPORT     16   variable
;_MaybeAToHL                         IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  108	
;  109	void AnsToDE(void) {
_AnsToDE:
;  110	    if (expr.outputRegister == REGISTER_HL) {
	LD	A,(_expr+10)
	OR	A,A
	JR	NZ,L_50
;  111	        EX_DE_HL();
	LD	BC,235
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	CALL	_RegChangeHLDE
	JR	L_51
;  112	    } else if (expr.outputRegister == REGISTER_A) {
L_50:
	LD	A,(_expr+10)
	CP	A,4
	JR	NZ,L_51
;  113	        LD_DE_IMM(0);
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_LoadRegValue
	POP	BC
	POP	BC
;  114	        LD_E_A();
	LD	BC,95
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	CALL	_ResetDE
;  115	        reg.DEIsNumber = reg.AIsNumber;
	LD	A,(_reg+6)
	LD	(_reg+2),A
;  116	        reg.DEIsVariable = false;
	XOR	A,A
	LD	(_reg+3),A
;  117	        reg.DEValue = reg.AValue;
	LD	A,(_reg+13)
	UEXT	HL
	LD	L,A
	LD	(_reg+19),HL
;  118	    }
L_51:
;  119	    expr.outputRegister = REGISTER_DE;
	LD	A,1
	LD	(_expr+10),A
;  120	}
	RET	


;**************************** _AnsToDE ***************************
;Name                         Addr/Register   Size   Type
;_reg                                IMPORT     28   variable
;_ResetDE                            IMPORT  -----   function
;_LoadRegValue                       IMPORT  -----   function
;_RegChangeHLDE                      IMPORT  -----   function
;_OutputWriteByte                    IMPORT  -----   function
;_expr                               IMPORT     16   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  121	
;  122	void AnsToBC(void) {
_AnsToBC:
;  123	    if (expr.outputRegister == REGISTER_A) {
	LD	A,(_expr+10)
	CP	A,4
	JR	NZ,L_62
;  124	        LD_BC_IMM(0);
	LD	BC,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_LoadRegValue
	POP	BC
	POP	BC
;  125	        LD_C_A();
	LD	BC,79
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	CALL	_ResetBC
;  126	        reg.BCIsNumber = reg.AIsNumber;
	LD	A,(_reg+6)
	LD	(_reg+4),A
;  127	        reg.BCIsVariable = reg.AIsVariable;
	LD	A,(_reg+7)
	LD	(_reg+5),A
;  128	        reg.BCValue = reg.AValue;
	LD	A,(_reg+13)
	UEXT	HL
	LD	L,A
	LD	(_reg+22),HL
;  129	    } else {
	JR	L_63
L_62:
;  130	        PushHLDE();
	CALL	_PushHLDE
;  131	        POP_BC();
	LD	BC,193
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	CALL	_ResetBC
;  132	    }
;  133	}
L_63:
	RET	


;**************************** _AnsToBC ***************************
;Name                         Addr/Register   Size   Type
;_PushHLDE                           IMPORT  -----   function
;_reg                                IMPORT     28   variable
;_ResetBC                            IMPORT  -----   function
;_OutputWriteByte                    IMPORT  -----   function
;_LoadRegValue                       IMPORT  -----   function
;_expr                               IMPORT     16   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  134	
;  135	void AnsToA(void) {
_AnsToA:
;  136	    if (expr.outputRegister == REGISTER_HL) {
	LD	A,(_expr+10)
	OR	A,A
	JR	NZ,L_70
;  137	        LD_A_L();
	LD	BC,125
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	CALL	_ResetA
	JR	L_71
;  138	    } else if (expr.outputRegister == REGISTER_DE) {
L_70:
	LD	A,(_expr+10)
	CP	A,1
	JR	NZ,L_71
;  139	        LD_A_E();
	LD	BC,123
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	CALL	_ResetA
;  140	    }
L_71:
;  141	    expr.outputRegister = REGISTER_A;
	LD	A,4
	LD	(_expr+10),A
;  142	}
	RET	


;**************************** _AnsToA ***************************
;Name                         Addr/Register   Size   Type
;_ResetA                             IMPORT  -----   function
;_OutputWriteByte                    IMPORT  -----   function
;_expr                               IMPORT     16   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  143	
;  144	void SetRegHLToRegDE(void) {
_SetRegHLToRegDE:
;  145	    reg.DEIsNumber = reg.HLIsNumber;
	LD	A,(_reg)
	LD	(_reg+2),A
;  146	    reg.DEIsVariable = reg.HLIsVariable;
	LD	A,(_reg+1)
	LD	(_reg+3),A
;  147	    reg.DEValue = reg.HLValue;
	LD	BC,(_reg+16)
	LD	(_reg+19),BC
;  148	    reg.DEVariable = reg.HLVariable;
	LD	A,(_reg+10)
	LD	(_reg+11),A
;  149	}
	RET	


;**************************** _SetRegHLToRegDE ***************************
;Name                         Addr/Register   Size   Type
;_reg                                IMPORT     28   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  150	
;  151	void SetRegDEToRegHL(void) {
_SetRegDEToRegHL:
;  152	    reg.HLIsNumber = reg.DEIsNumber;
	LD	A,(_reg+2)
	LD	(_reg),A
;  153	    reg.HLIsVariable = reg.DEIsVariable;
	LD	A,(_reg+3)
	LD	(_reg+1),A
;  154	    reg.HLValue = reg.DEValue;
	LD	BC,(_reg+19)
	LD	(_reg+16),BC
;  155	    reg.HLVariable = reg.DEVariable;
	LD	A,(_reg+11)
	LD	(_reg+10),A
;  156	}
	RET	


;**************************** _SetRegDEToRegHL ***************************
;Name                         Addr/Register   Size   Type
;_reg                                IMPORT     28   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  157	
;  158	void ClearAnsFlags(void) {
_ClearAnsFlags:
;  159	    expr.AnsSetZeroFlag = expr.AnsSetZeroFlagReversed = expr.AnsSetCarryFlag = expr.AnsSetCarryFlagReversed = false;
	XOR	A,A
	LD	(_expr+8),A
	LD	(_expr+7),A
	LD	(_expr+6),A
	LD	(_expr+5),A
;  160	}
	RET	


;**************************** _ClearAnsFlags ***************************
;Name                         Addr/Register   Size   Type
;_expr                               IMPORT     16   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  161	
;  162	void ChangeRegValue(uint24_t inValue, uint24_t outValue, uint8_t opcodes[7]) {
_ChangeRegValue:
	LD	HL,-7
	CALL	__frameset
;  163	    expr.SizeOfOutputNumber = 0;
	XOR	A,A
	LD	(_expr+12),A
;  164	
;  165	    if (reg.allowedToOptimize) {
	LD	A,(_reg+9)
	OR	A,A
	JR	Z,L_108
;  166	        uint8_t a;
;  167	        if (outValue - inValue < 5) {
	LD	BC,(IX+6)
	LD	HL,(IX+9)
	OR	A,A
	SBC	HL,BC
	LD	(IX+-4),HL
	OR	A,A
	LD	BC,5
	SBC	HL,BC
	JR	NC,L_106
;  168	            for (a = 0; a < (uint8_t)(outValue - inValue); a++) {
	LD	(IX+-1),0
	JR	L_80
L_78:
;  169	                OutputWriteByte(opcodes[0]);
	LD	HL,(IX+12)
	LD	C,(HL)
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  170	                expr.SizeOfOutputNumber++;
	LD	A,(_expr+12)
	INC	A
	LD	(_expr+12),A
	INC	(IX+-1)
;  171	            }
L_80:
	LD	B,(IX+-4)
	LD	A,(IX+-1)
	CP	A,B
	JR	C,L_78
	JR	L_109
;  172	        } else if (inValue - outValue < 5) {
L_106:
	LD	BC,(IX+9)
	LD	HL,(IX+6)
	OR	A,A
	SBC	HL,BC
	LD	(IX+-7),HL
	OR	A,A
	LD	BC,5
	SBC	HL,BC
	JR	NC,L_104
;  173	            for (a = 0; a < (uint8_t)(inValue - outValue); a++) {
	LD	(IX+-1),0
	JR	L_85
L_83:
;  174	                OutputWriteByte(opcodes[1]);
	LD	HL,(IX+12)
	INC	HL
	LD	C,(HL)
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  175	                expr.SizeOfOutputNumber++;
	LD	A,(_expr+12)
	INC	A
	LD	(_expr+12),A
	INC	(IX+-1)
;  176	            }
L_85:
	LD	B,(IX+-7)
	LD	A,(IX+-1)
	CP	A,B
	JR	C,L_83
	JR	L_109
;  177	        } else if (inValue < 256 && outValue < 512) {
L_104:
	LD	BC,256
	LD	HL,(IX+6)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_102
	LD	BC,512
	LD	HL,(IX+9)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_102
;  178	            if (outValue > 255) {
	LD	BC,(IX+9)
	LD	HL,255
	OR	A,A
	SBC	HL,BC
	JR	NC,L_89
;  179	                OutputWriteByte(opcodes[2]);
	LD	IY,(IX+12)
	LEA	HL,IY+2
	LD	C,(HL)
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  180	                expr.SizeOfOutputNumber = 1;
	LD	A,1
	LD	(_expr+12),A
;  181	            }
L_89:
;  182	            if (inValue != (outValue & 255)) {
	LD	A,(IX+9)
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,(IX+6)
	SBC	HL,BC
	JR	Z,L_109
;  183	                OutputWriteByte(opcodes[4]);
	LD	IY,(IX+12)
	LEA	HL,IY+4
	LD	C,(HL)
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  184	                OutputWriteByte(outValue);
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  185	                expr.SizeOfOutputNumber += 2;
	LD	A,(_expr+12)
	INC	A
	INC	A
	LD	(_expr+12),A
;  186	            }
;  187	        } else if (inValue < 512 && outValue < 256) {
	JR	L_109
L_102:
	LD	BC,512
	LD	HL,(IX+6)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_100
	LD	BC,256
	LD	HL,(IX+9)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_100
;  188	            OutputWriteByte(opcodes[3]);
	LD	IY,(IX+12)
	LEA	HL,IY+3
	LD	C,(HL)
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  189	            expr.SizeOfOutputNumber = 1;
	LD	A,1
	LD	(_expr+12),A
;  190	            if ((inValue & 255) != outValue) {
	LD	A,(IX+6)
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,(IX+9)
	SBC	HL,BC
	JR	Z,L_109
;  191	                OutputWriteByte(opcodes[4]);
	LD	IY,(IX+12)
	LEA	HL,IY+4
	LD	C,(HL)
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  192	                OutputWriteByte(outValue);
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  193	                expr.SizeOfOutputNumber = 3;
	LD	A,3
	LD	(_expr+12),A
;  194	            }
;  195	        } else if (inValue < 65536 && outValue < 65536 && (inValue & 255) == (outValue & 255)) {
	JR	L_109
L_100:
	LD	BC,65536
	LD	HL,(IX+6)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_98
	LD	HL,(IX+9)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_98
	LD	A,(IX+6)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	A,(IX+9)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_98
;  196	            OutputWriteByte(opcodes[5]);
	LD	IY,(IX+12)
	LEA	HL,IY+5
	LD	C,(HL)
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  197	            OutputWriteByte(outValue >> 8);
	LD	HL,(IX+9)
	LD	A,8
	CALL	__ishru_b
	LD	C,L
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  198	            expr.SizeOfOutputNumber = 2;
	LD	A,2
	LD	(_expr+12),A
;  199	        } else if (outValue >= IX_VARIABLES - 0x80 && outValue <= IX_VARIABLES + 0x7F) {
	JR	L_109
L_98:
	LD	BC,13713095
	LD	HL,(IX+9)
	OR	A,A
	SBC	HL,BC
	JR	C,L_96
	LD	BC,(IX+9)
	LD	HL,13713350
	OR	A,A
	SBC	HL,BC
	JR	C,L_96
;  200	            OutputWrite2Bytes(0xED, 0x22);
	LD	BC,8941
	PUSH	BC
	CALL	_OutputWriteWord
	POP	BC
;  201	            OutputWriteByte(outValue - IX_VARIABLES);
	LD	A,(IX+9)
	SUB	A,71
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  202	            expr.SizeOfOutputNumber = 3;
	LD	A,3
	LD	(_expr+12),A
;  203	        } else {
	JR	L_109
L_96:
;  204	            OutputWriteByte(opcodes[6]);
	LD	IY,(IX+12)
	LEA	HL,IY+6
	LD	C,(HL)
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  205	            OutputWriteLong(outValue);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
;  206	            expr.SizeOfOutputNumber = 4;
	LD	A,4
	LD	(_expr+12),A
;  207	        }
;  208	    } else {
	JR	L_109
L_108:
;  209	        OutputWriteByte(opcodes[6]);
	LD	IY,(IX+12)
	LEA	HL,IY+6
	LD	C,(HL)
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  210	        OutputWriteLong(outValue);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
;  211	        expr.SizeOfOutputNumber = 4;
	LD	A,4
	LD	(_expr+12),A
;  212	    }
L_109:
;  213	    reg.allowedToOptimize = true;
	LD	A,1
	LD	(_reg+9),A
;  214	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _ChangeRegValue ***************************
;Name                         Addr/Register   Size   Type
;_OutputWriteLong                    IMPORT  -----   function
;_OutputWriteWord                    IMPORT  -----   function
;_OutputWriteByte                    IMPORT  -----   function
;_reg                                IMPORT     28   variable
;_expr                               IMPORT     16   variable
;G_3                                   IX-7      3   variable
;G_2                                   IX-4      3   variable
;a                                     IX-1      1   variable
;opcodes                              IX+12      3   parameter
;outValue                              IX+9      3   parameter
;inValue                               IX+6      3   parameter


; Stack Frame Size: 22 (bytes)
;       Spill Code: 0 (instruction)


;  215	
;  216	void LoadRegValue(uint8_t reg2, uint24_t val) {
_LoadRegValue:
	LD	HL,-14
	CALL	__frameset
;  217	    if (reg2 == REGISTER_HL) {
	LD	A,(IX+6)
	OR	A,A
	JR	NZ,L_130
;  218	        if (reg.HLIsNumber) {
	LD	A,(_reg)
	OR	A,A
	JR	Z,L_121
;  219	            uint8_t opcodes[7] = {OP_INC_HL, OP_DEC_HL, OP_INC_H, OP_DEC_H, OP_LD_L, OP_LD_H, OP_LD_HL};
	LEA	DE,IX+-7
;  220	
;  221	            ChangeRegValue(reg.HLValue, val, opcodes);
	PEA	IX+-7
	LD	HL,_1temp111
	LD	BC,7
	LDIR	
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(_reg+16)
	PUSH	BC
	CALL	_ChangeRegValue
	POP	BC
	POP	BC
	POP	BC
;  222	        } else if (val) {
	JR	L_122
L_121:
	LD	HL,(IX+9)
	CALL	__icmpzero
	JR	Z,L_119
;  223	            OutputWriteByte(OP_LD_HL);
	LD	BC,33
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  224	            OutputWriteLong(val);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
;  225	            expr.SizeOfOutputNumber = 4;
	LD	A,4
	LD	(_expr+12),A
;  226	        } else {
	JR	L_122
L_119:
;  227	            OR_A_A();
	LD	BC,183
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  228	            SBC_HL_HL();
	LD	BC,25325
	PUSH	BC
	CALL	_OutputWriteWord
	POP	BC
	CALL	_ResetHL
;  229	            expr.SizeOfOutputNumber = 3;
	LD	A,3
	LD	(_expr+12),A
;  230	        }
L_122:
;  231	        reg.HLIsNumber = true;
	LD	A,1
	LD	(_reg),A
;  232	        reg.HLIsVariable = false;
	XOR	A,A
	LD	(_reg+1),A
;  233	        reg.HLValue = val;
	LD	BC,(IX+9)
	LD	(_reg+16),BC
;  234	    } else if (reg2 == REGISTER_DE) {
	JR	L_131
L_130:
	LD	A,(IX+6)
	CP	A,1
	JR	NZ,L_128
;  235	        if (reg.DEIsNumber) {
	LD	A,(_reg+2)
	OR	A,A
	JR	Z,L_125
;  236	            uint8_t opcodes[7] = {OP_INC_DE, OP_DEC_DE, OP_INC_D, OP_DEC_D, OP_LD_E, OP_LD_D, OP_LD_DE};
	LEA	DE,IX+-14
;  237	
;  238	            ChangeRegValue(reg.DEValue, val, opcodes);
	PEA	IX+-14
	LD	HL,_2temp123
	LD	BC,7
	LDIR	
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(_reg+19)
	PUSH	BC
	CALL	_ChangeRegValue
	POP	BC
	POP	BC
	POP	BC
;  239	        } else {
	JR	L_126
L_125:
;  240	            OutputWriteByte(OP_LD_DE);
	LD	BC,17
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  241	            OutputWriteLong(val);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
;  242	            expr.SizeOfOutputNumber = 4;
	LD	A,4
	LD	(_expr+12),A
;  243	        }
L_126:
;  244	        reg.DEIsNumber = true;
	LD	A,1
	LD	(_reg+2),A
;  245	        reg.DEIsVariable = false;
	XOR	A,A
	LD	(_reg+3),A
;  246	        reg.DEValue = val;
	LD	BC,(IX+9)
	LD	(_reg+19),BC
;  247	    } else {
	JR	L_131
L_128:
;  248	        reg.BCIsNumber = true;
	LD	A,1
	LD	(_reg+4),A
;  249	        reg.BCIsVariable = false;
	XOR	A,A
	LD	(_reg+5),A
;  250	        reg.BCValue = val;
	LD	DE,(IX+9)
;  251	        OutputWriteByte(OP_LD_BC);
	LD	BC,1
	PUSH	BC
	LD	(_reg+22),DE
	CALL	_OutputWriteByte
	POP	BC
;  252	        OutputWriteLong(val);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
;  253	        expr.SizeOfOutputNumber = 4;
	LD	A,4
	LD	(_expr+12),A
;  254	    }
;  255	}
L_131:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _LoadRegValue ***************************
;Name                         Addr/Register   Size   Type
;_2temp123                           STATIC      7   variable
;_ResetHL                            IMPORT  -----   function
;_OutputWriteWord                    IMPORT  -----   function
;_expr                               IMPORT     16   variable
;_OutputWriteLong                    IMPORT  -----   function
;_OutputWriteByte                    IMPORT  -----   function
;_ChangeRegValue                     IMPORT  -----   function
;_1temp111                           STATIC      7   variable
;_reg                                IMPORT     28   variable
;opcodes                              IX-14      7   variable
;opcodes                               IX-7      7   variable
;val                                   IX+9      3   parameter
;reg2                                  IX+6      1   parameter


; Stack Frame Size: 26 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT TEXT
_1temp111:
	DB	35
	DB	43
	DB	36
	DB	37
	DB	46
	DB	38
	DB	33
_2temp123:
	DB	19
	DB	27
	DB	20
	DB	21
	DB	30
	DB	22
	DB	17
	SEGMENT CODE
;  256	
;  257	void LoadRegVariable(uint8_t reg2, uint8_t variable) {
_LoadRegVariable:
	CALL	__frameset0
;  258	    if (reg2 == REGISTER_HL) {
	LD	A,(IX+6)
	OR	A,A
	JR	NZ,L_141
;  259	        if (!(reg.HLIsVariable && reg.HLVariable == variable)) {
	LD	A,(_reg+1)
	OR	A,A
	JR	Z,L_133
	LD	A,(_reg+10)
	CP	A,(IX+9)
	JR	Z,L_142
L_133:
;  260	            OutputWrite2Bytes(0xDD, 0x27);
	LD	BC,10205
	PUSH	BC
	CALL	_OutputWriteWord
	POP	BC
;  261	            OutputWriteByte(variable);
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  262	            reg.HLIsNumber = false;
	XOR	A,A
	LD	(_reg),A
;  263	            reg.HLIsVariable = true;
	LD	A,1
	LD	(_reg+1),A
;  264	            reg.HLVariable = variable;
	LD	A,(IX+9)
	LD	(_reg+10),A
;  265	        }
;  266	    } else if (reg2 == REGISTER_DE) {
	JR	L_142
L_141:
	LD	A,(IX+6)
	CP	A,1
	JR	NZ,L_139
;  267	        if (!(reg.DEIsVariable && reg.DEVariable == variable)) {
	LD	A,(_reg+3)
	OR	A,A
	JR	Z,L_135
	LD	A,(_reg+11)
	CP	A,(IX+9)
	JR	Z,L_142
L_135:
;  268	            OutputWrite2Bytes(0xDD, 0x17);
	LD	BC,6109
	PUSH	BC
	CALL	_OutputWriteWord
	POP	BC
;  269	            OutputWriteByte(variable);
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  270	            reg.DEIsNumber = false;
	XOR	A,A
	LD	(_reg+2),A
;  271	            reg.DEIsVariable = true;
	LD	A,1
	LD	(_reg+3),A
;  272	            reg.DEVariable = variable;
	LD	A,(IX+9)
	LD	(_reg+11),A
;  273	        }
;  274	    } else if (reg2 == REGISTER_BC) {
	JR	L_142
L_139:
	LD	A,(IX+6)
	CP	A,2
	JR	NZ,L_137
;  275	        reg.BCIsNumber = false;
	XOR	A,A
	LD	(_reg+4),A
;  276	        reg.BCIsVariable = true;
	LD	A,1
	LD	(_reg+5),A
;  277	        reg.BCVariable = variable;
	LD	A,(IX+9)
;  278	        OutputWrite2Bytes(0xDD, 0x07);
	LD	BC,2013
	PUSH	BC
	LD	(_reg+12),A
	CALL	_OutputWriteWord
	POP	BC
;  279	        OutputWriteByte(variable);
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  280	    } else {
	JR	L_142
L_137:
;  281	        reg.AIsNumber = false;
	XOR	A,A
	LD	(_reg+6),A
;  282	        reg.AIsVariable = true;
	LD	A,1
	LD	(_reg+7),A
;  283	        reg.AVariable = variable;
	LD	A,(IX+9)
;  284	        OutputWrite2Bytes(0xDD, 0x7E);
	LD	BC,32477
	PUSH	BC
	LD	(_reg+14),A
	CALL	_OutputWriteWord
	POP	BC
;  285	        OutputWriteByte(variable);
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  286	    }
;  287	}
L_142:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _LoadRegVariable ***************************
;Name                         Addr/Register   Size   Type
;_OutputWriteByte                    IMPORT  -----   function
;_OutputWriteWord                    IMPORT  -----   function
;_reg                                IMPORT     28   variable
;variable                              IX+9      1   parameter
;reg2                                  IX+6      1   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;  288	
;  289	void ResetAllRegs(void) {
_ResetAllRegs:
;  290	    reg.HLIsNumber = reg.HLIsVariable = reg.DEIsNumber = reg.DEIsVariable = reg.BCIsNumber = reg.BCIsVariable = reg.AIsNumber = reg.AIsVariable = false;
	XOR	A,A
	LD	(_reg+7),A
	LD	(_reg+6),A
	LD	(_reg+5),A
	LD	(_reg+4),A
	LD	(_reg+3),A
	LD	(_reg+2),A
	LD	(_reg+1),A
	LD	(_reg),A
;  291	}
	RET	


;**************************** _ResetAllRegs ***************************
;Name                         Addr/Register   Size   Type
;_reg                                IMPORT     28   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  292	
;  293	void ResetHL(void) {
_ResetHL:
;  294	    reg.HLIsNumber = reg.HLIsVariable = false;
	XOR	A,A
	LD	(_reg+1),A
	LD	(_reg),A
;  295	}
	RET	


;**************************** _ResetHL ***************************
;Name                         Addr/Register   Size   Type
;_reg                                IMPORT     28   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  296	
;  297	void ResetDE(void) {
_ResetDE:
;  298	    reg.DEIsNumber = reg.DEIsVariable = false;
	XOR	A,A
	LD	(_reg+3),A
	LD	(_reg+2),A
;  299	}
	RET	


;**************************** _ResetDE ***************************
;Name                         Addr/Register   Size   Type
;_reg                                IMPORT     28   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  300	
;  301	void ResetBC(void) {
_ResetBC:
;  302	    reg.BCIsNumber = reg.BCIsVariable = false;
	XOR	A,A
	LD	(_reg+5),A
	LD	(_reg+4),A
;  303	}
	RET	


;**************************** _ResetBC ***************************
;Name                         Addr/Register   Size   Type
;_reg                                IMPORT     28   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  304	
;  305	void ResetA(void) {
_ResetA:
;  306	    reg.AIsNumber = reg.AIsVariable = false;
	XOR	A,A
	LD	(_reg+7),A
	LD	(_reg+6),A
;  307	}
	RET	


;**************************** _ResetA ***************************
;Name                         Addr/Register   Size   Type
;_reg                                IMPORT     28   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  308	
;  309	void RegChangeHLDE(void) {
_RegChangeHLDE:
	LD	HL,-4
	CALL	__frameset
;  310	    uint8_t  temp8;
;  311	    uint24_t temp24;
;  312	
;  313	    temp8 = reg.HLIsNumber;
	LD	A,(_reg)
	LD	(IX+-1),A
;  314	    reg.HLIsNumber = reg.DEIsNumber;
	LD	A,(_reg+2)
	LD	(_reg),A
;  315	    reg.DEIsNumber = temp8;
	LD	A,(IX+-1)
	LD	(_reg+2),A
;  316	    temp24 = reg.HLValue;
	LD	BC,(_reg+16)
	LD	(IX+-4),BC
;  317	    reg.HLValue = reg.DEValue;
	LD	BC,(_reg+19)
	LD	(_reg+16),BC
;  318	    reg.DEValue = temp24;
	LD	BC,(IX+-4)
	LD	(_reg+19),BC
;  319	
;  320	    temp8 = reg.HLIsVariable;
	LD	A,(_reg+1)
	LD	(IX+-1),A
;  321	    reg.HLIsVariable = reg.DEIsVariable;
	LD	A,(_reg+3)
	LD	(_reg+1),A
;  322	    reg.DEIsVariable = temp8;
	LD	A,(IX+-1)
	LD	(_reg+3),A
;  323	    temp8 = reg.HLVariable;
	LD	A,(_reg+10)
	LD	(IX+-1),A
;  324	    reg.HLVariable = reg.DEVariable;
	LD	A,(_reg+11)
	LD	(_reg+10),A
;  325	    reg.DEVariable = temp8;
	LD	A,(IX+-1)
	LD	(_reg+11),A
;  326	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _RegChangeHLDE ***************************
;Name                         Addr/Register   Size   Type
;_reg                                IMPORT     28   variable
;temp24                                IX-4      3   variable
;temp8                                 IX-1      1   variable


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


;  327	
;  328	void MaybeAToHL(void) {
_MaybeAToHL:
;  329	    if (expr.outputRegister == REGISTER_A) {
	LD	A,(_expr+10)
	CP	A,4
	JR	NZ,L_159
;  330	        OR_A_A();
	LD	BC,183
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  331	        SBC_HL_HL();
	LD	BC,25325
	PUSH	BC
	CALL	_OutputWriteWord
	POP	BC
	CALL	_ResetHL
;  332	        LD_L_A();
	LD	BC,111
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	CALL	_ResetHL
;  333	        reg.HLIsNumber = reg.AIsNumber;
	LD	A,(_reg+6)
	LD	(_reg),A
;  334	        reg.HLIsVariable = false;
	XOR	A,A
	LD	(_reg+1),A
;  335	        reg.HLValue = reg.AValue;
	LD	A,(_reg+13)
	UEXT	HL
	LD	L,A
	LD	(_reg+16),HL
;  336	        expr.outputRegister = REGISTER_HL;
	XOR	A,A
	LD	(_expr+10),A
;  337	    }
;  338	}
L_159:
	RET	


;**************************** _MaybeAToHL ***************************
;Name                         Addr/Register   Size   Type
;_reg                                IMPORT     28   variable
;_ResetHL                            IMPORT  -----   function
;_OutputWriteWord                    IMPORT  -----   function
;_OutputWriteByte                    IMPORT  -----   function
;_expr                               IMPORT     16   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  339	
;  340	void SeekMinus1(void) {
_SeekMinus1:
;  341	    _seek(-1, SEEK_CUR, ice.inPrgm);
	LD	A,(_ice+10904)
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,16777215
	PUSH	BC
	CALL	_ti_Seek
	POP	BC
	POP	BC
	POP	BC
;  342	}
	RET	


;**************************** _SeekMinus1 ***************************
;Name                         Addr/Register   Size   Type
;_ice                                IMPORT  10958   variable
;_ti_Seek                            IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  343	
;  344	void displayMessageLineScroll(char *string) {
_displayMessageLineScroll:
	LD	HL,-1
	CALL	__frameset
;  345	#ifdef CALCULATOR
;  346	    char c;
;  347	
;  348	    gfx_SetTextXY(1, gfx_GetTextY());
	CALL	_gfx_GetTextY
	PUSH	HL
	LD	BC,1
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  349	
;  350	    // Display the string
;  351	    while(c = *string++) {
	JR	L_167
L_168:
;  352	        if (gfx_GetTextY() > 190) {
	CALL	_gfx_GetTextY
	LD	BC,HL
	LD	HL,190
	OR	A,A
	SBC	HL,BC
	JP	P,L_164
;  353	            gfx_SetClipRegion(0, 11, 320, LB_Y - 1);
	LD	BC,209
	PUSH	BC
	LD	BC,320
	PUSH	BC
	LD	BC,11
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_gfx_SetClipRegion
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  354	            gfx_ShiftUp(10);
	LD	BC,10
	PUSH	BC
	CALL	_gfx_ShiftUp
	POP	BC
;  355	            gfx_SetColor(255);
	LD	BC,255
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  356	            gfx_SetClipRegion(0, 0, 320, 240);
	LD	BC,240
	PUSH	BC
	LD	BC,320
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	CALL	_gfx_SetClipRegion
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  357	            gfx_FillRectangle(0, LB_Y - 11, 320, 10);
	LD	BC,10
	PUSH	BC
	LD	BC,320
	PUSH	BC
	LD	BC,199
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_gfx_FillRectangle
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  358	            gfx_SetTextXY(1, gfx_GetTextY() - 10);
	CALL	_gfx_GetTextY
	LD	IY,HL
	LEA	BC,IY+-10
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  359	        }
L_164:
;  360	        if (c == tTheta) {
	LD	A,(IX+-1)
	CP	A,91
	JR	NZ,L_165
;  361	            c = 0x40;
	LD	(IX+-1),64
;  362	        }
L_165:
;  363	        gfx_PrintChar(c);
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	CALL	_gfx_PrintChar
	POP	BC
;  364	        if (gfx_GetTextX() > 312) {
	CALL	_gfx_GetTextX
	LD	BC,HL
	LD	HL,312
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_167
;  365	            gfx_SetTextXY(1, gfx_GetTextY() + 10);
	CALL	_gfx_GetTextY
	LD	IY,HL
	LEA	BC,IY+10
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  366	        }
;  367	    }
L_167:
	LD	HL,(IX+6)
	LD	A,(HL)
	LD	(IX+-1),A
	LD	BC,(IX+6)
	INC	BC
	LD	(IX+6),BC
	LD	A,(IX+-1)
	OR	A,A
	JR	NZ,L_168
;  368	    gfx_SetTextXY(1, gfx_GetTextY() + 10);
	CALL	_gfx_GetTextY
	LD	IY,HL
	LEA	BC,IY+10
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  369	#else
;  370	    fprintf(stdout, "%s\n", string);
;  371	#endif
;  372	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _displayMessageLineScroll ***************************
;Name                         Addr/Register   Size   Type
;_gfx_GetTextX                       IMPORT  -----   function
;_gfx_PrintChar                      IMPORT  -----   function
;_gfx_FillRectangle                  IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function
;_gfx_ShiftUp                        IMPORT  -----   function
;_gfx_SetClipRegion                  IMPORT  -----   function
;_gfx_GetTextY                       IMPORT  -----   function
;_gfx_SetTextXY                      IMPORT  -----   function
;c                                     IX-1      1   variable
;string                                IX+6      3   parameter


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


;  373	
;  374	void MaybeLDIYFlags(void) {
_MaybeLDIYFlags:
;  375	    if (ice.modifiedIY) {
	LD	A,(_ice+10908)
	OR	A,A
	JR	Z,L_175
;  376	        LD_IY_IMM(flags);
	LD	BC,8701
	PUSH	BC
	CALL	_OutputWriteWord
	POP	BC
	LD	BC,13631616
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
;  377	        ice.modifiedIY = false;
	XOR	A,A
	LD	(_ice+10908),A
;  378	    }
;  379	}
L_175:
	RET	


;**************************** _MaybeLDIYFlags ***************************
;Name                         Addr/Register   Size   Type
;_OutputWriteLong                    IMPORT  -----   function
;_OutputWriteWord                    IMPORT  -----   function
;_ice                                IMPORT  10958   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  380	
;  381	void PushHLDE(void) {
_PushHLDE:
;  382	    MaybeAToHL();
	CALL	_MaybeAToHL
;  383	    if (expr.outputRegister == REGISTER_HL) {
	LD	A,(_expr+10)
	OR	A,A
	JR	NZ,L_181
;  384	        PUSH_HL();
	LD	BC,229
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	JR	L_182
;  385	    } else {
L_181:
;  386	        PUSH_DE();
	LD	BC,213
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  387	    }
;  388	}
L_182:
	RET	


;**************************** _PushHLDE ***************************
;Name                         Addr/Register   Size   Type
;_OutputWriteByte                    IMPORT  -----   function
;_expr                               IMPORT     16   variable
;_MaybeAToHL                         IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  389	
;  390	uint8_t IsHexadecimal(int token) {
_IsHexadecimal:
	CALL	__frameset0
;  391	    uint8_t tok = token;
;  392	
;  393	    if (tok >= t0 && tok <= t9) {
	LD	A,(IX+6)
	CP	A,48
	JR	C,L_188
	LD	B,(IX+6)
	LD	A,57
	CP	A,B
	JR	C,L_188
;  394	        return tok - t0;
	LD	A,(IX+6)
	SUB	A,48
	JR	L_189
;  395	    } else if (tok >= tA && tok <= tF) {
L_188:
	LD	A,(IX+6)
	CP	A,65
	JR	C,L_186
	LD	B,(IX+6)
	LD	A,70
	CP	A,B
	JR	C,L_186
;  396	        return tok - tA + 10;
	LD	A,(IX+6)
	ADD	A,-55
	JR	L_189
;  397	    } else {
L_186:
;  398	        return 16;
	LD	A,16
;  399	    }
;  400	}
L_189:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _IsHexadecimal ***************************
;Name                         Addr/Register   Size   Type
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  401	
;  402	bool CheckEOL(void) {
_CheckEOL:
	LD	HL,-3
	CALL	__frameset
;  403	    int token;
;  404	
;  405	    if ((token = _getc()) == EOF || (uint8_t)token == tEnter || (uint8_t)token == tColon) {
	CALL	_getNextToken
	LD	(IX+-3),HL
	LD	BC,16777215
	OR	A,A
	SBC	HL,BC
	JR	Z,L_192
	LD	A,(IX+-3)
	CP	A,63
	JR	Z,L_192
	LD	A,(IX+-3)
	CP	A,62
	JR	NZ,L_193
L_192:
;  406	        return true;
	LD	A,1
	JR	L_194
;  407	    }
L_193:
;  408	    return false;
	XOR	A,A
;  409	}
L_194:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _CheckEOL ***************************
;Name                         Addr/Register   Size   Type
;_getNextToken                       IMPORT  -----   function
;token                                 IX-3      3   variable


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  410	
;  411	void CallRoutine(bool *routineBool, uint24_t *routineAddress, const uint8_t *routineData, uint8_t routineLength) {
_CallRoutine:
	CALL	__frameset0
;  412	    // Store the pointer to the call to the stack, to replace later
;  413	    ProgramPtrToOffsetStack();
	CALL	_ProgramPtrToOffsetStack
;  414	
;  415	    // We need to add the routine to the data section
;  416	    if (!*routineBool) {
	LD	HL,(IX+6)
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_198
;  417	        ice.programDataPtr -= routineLength;
	LD	A,(IX+15)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(_ice+66)
	OR	A,A
	SBC	HL,BC
	LD	(_ice+66),HL
;  418	        *routineAddress = (uintptr_t)ice.programDataPtr;
	LD	HL,(IX+9)
	LD	BC,(_ice+66)
	LD	(HL),BC
;  419	        memcpy(ice.programDataPtr, routineData, routineLength);
	LD	A,(IX+15)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	BC,(IX+12)
	PUSH	BC
	LD	BC,(_ice+66)
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  420	        *routineBool = true;
	LD	HL,(IX+6)
	LD	(HL),1
;  421	    }
L_198:
;  422	
;  423	    CALL(*routineAddress);
	LD	BC,205
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	HL,(IX+9)
	LD	BC,(HL)
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
;  424	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _CallRoutine ***************************
;Name                         Addr/Register   Size   Type
;_OutputWriteLong                    IMPORT  -----   function
;_OutputWriteByte                    IMPORT  -----   function
;_memcpy                             IMPORT  -----   function
;_ice                                IMPORT  10958   variable
;_ProgramPtrToOffsetStack            IMPORT  -----   function
;routineLength                        IX+15      1   parameter
;routineData                          IX+12      3   parameter
;routineAddress                        IX+9      3   parameter
;routineBool                           IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


;  425	
;  426	uint8_t GetVariableOffset(uint8_t tok) {
_GetVariableOffset:
	LD	HL,-26
	CALL	__frameset
;  427	    char variableName[21] = {0};
	LEA	DE,IX+-26
	LD	HL,_3temp200
	LD	BC,21
	LDIR	
;  428	    variable_t *variableNew;
;  429	    uint8_t a = 1, b;
	LD	(IX+-1),1
;  430	
;  431	    variableName[0] = tok;
	LD	A,(IX+6)
	LD	(IX+-26),A
;  432	    while ((tok = _getc()) >= tA && tok <= tTheta && a < 20) {
	JR	L_204
L_205:
;  433	        variableName[a++] = tok;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LEA	HL,IX+-26
	ADD	HL,BC
	LD	A,(IX+6)
	LD	(HL),A
	INC	(IX+-1)
;  434	    }
L_204:
	CALL	_getNextToken
	LD	(IX+6),L
	LD	A,(IX+6)
	CP	A,65
	JR	C,L_206
	LD	A,91
	CP	A,(IX+6)
	JR	C,L_206
	LD	A,(IX+-1)
	CP	A,20
	JR	C,L_205
L_206:
;  435	    variableName[a] = 0;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LEA	HL,IX+-26
	ADD	HL,BC
	LD	(HL),0
;  436	    if (tok != 0xFF) {
	LD	A,(IX+6)
	CP	A,255
	JR	Z,L_213
;  437	        SeekMinus1();
	CALL	_SeekMinus1
;  438	    }
L_213:
;  439	
;  440	    // This variable already exists
;  441	    for (b = 0; b < prescan.amountOfVariablesUsed; b++) {
	LD	(IX+-2),0
	JR	L_212
L_210:
;  442	        if (!strcmp(variableName, (&prescan.variables[b])->name)) {
	LD	A,(IX+-2)
	UEXT	HL
	LD	L,A
	LD	A,21
	CALL	__imul_b
	LD	BC,_prescan+478
	ADD	HL,BC
	LD	IY,HL
	PEA	IY+0
	PEA	IX+-26
	CALL	_strcmp
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_211
;  443	            return b * 3 - 128;
	LD	B,3
	LD	C,(IX+-2)
	MLT	BC
	LD	A,C
	SUB	A,128
	JR	L_216
;  444	        }
;  445	    }
L_211:
	INC	(IX+-2)
L_212:
	LD	A,(IX+-2)
	LD	HL,_prescan+18
	CP	A,(HL)
	JR	C,L_210
;  446	
;  447	    // Create new variable
;  448	    variableNew = &prescan.variables[prescan.amountOfVariablesUsed];
	LD	A,(_prescan+18)
	UEXT	HL
	LD	L,A
	LD	A,21
	CALL	__imul_b
	LD	BC,_prescan+478
	ADD	HL,BC
	LD	(IX+-5),HL
;  449	    memcpy(variableNew->name, variableName, a + 1);
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	INC	HL
	PUSH	HL
	PEA	IX+-26
	LD	IY,(IX+-5)
	PEA	IY+0
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  450	
;  451	    return prescan.amountOfVariablesUsed++ * 3 - 128;
	LD	A,(_prescan+18)
	LD	B,A
	LD	A,(_prescan+18)
	LD	D,3
	LD	E,B
	INC	A
	LD	(_prescan+18),A
	MLT	DE
	LD	A,E
	SUB	A,128
;  452	}
L_216:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _GetVariableOffset ***************************
;Name                         Addr/Register   Size   Type
;_memcpy                             IMPORT  -----   function
;_prescan                            IMPORT   5833   variable
;_strcmp                             IMPORT  -----   function
;_SeekMinus1                         IMPORT  -----   function
;_getNextToken                       IMPORT  -----   function
;_3temp200                           STATIC     21   variable
;variableName                         IX-26     21   variable
;variableNew                           IX-5      3   variable
;b                                     IX-2      1   variable
;a                                     IX-1      1   variable
;tok                                   IX+6      1   parameter


; Stack Frame Size: 35 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT TEXT
_3temp200:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	SEGMENT CODE
;  453	
;  454	#ifdef CALCULATOR
;  455	
;  456	void displayLoadingBarFrame(void) {
_displayLoadingBarFrame:
;  457	    // Display a fancy loading bar during compiling ;)
;  458	    gfx_SetColor(0);
	LD	BC,0
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  459	    gfx_Rectangle_NoClip(LB_X, LB_Y, LB_W, LB_H);
	LD	BC,10
	PUSH	BC
	LD	BC,160
	PUSH	BC
	LD	BC,210
	PUSH	BC
	LD	BC,80
	PUSH	BC
	CALL	_gfx_Rectangle_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  460	    gfx_SetColor(255);
	LD	BC,255
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  461	    gfx_FillRectangle_NoClip(LB_X + 1, LB_Y + 1, LB_W - 2, LB_H - 2);
	LD	BC,8
	PUSH	BC
	LD	BC,158
	PUSH	BC
	LD	BC,211
	PUSH	BC
	LD	BC,81
	PUSH	BC
	CALL	_gfx_FillRectangle_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  462	}
	RET	


;**************************** _displayLoadingBarFrame ***************************
;Name                         Addr/Register   Size   Type
;_gfx_FillRectangle_NoClip           IMPORT  -----   function
;_gfx_Rectangle_NoClip               IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  463	
;  464	void displayLoadingBar(void) {
_displayLoadingBar:
	LD	HL,-4
	CALL	__frameset
;  465	    gfx_SetColor(4);
	LD	BC,4
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  466	    gfx_FillRectangle_NoClip(LB_X + 1, LB_Y + 1, ti_Tell(ice.inPrgm) * (LB_W - 2) / ti_GetSize(ice.inPrgm), LB_H - 2);
	LD	A,(_ice+10904)
	LD	C,A
	LD	DE,8
	PUSH	DE
	LD	B,0
	PUSH	BC
	CALL	_ti_Tell
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	LD	A,158
	CALL	__imul_b
	LD	A,(_ice+10904)
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	DE,HL
	LD	(IX+-3),DE
	LD	(IX+-4),D
	CALL	_ti_GetSize
	LD	DE,(IX+-3)
	LD	D,(IX+-4)
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	CALL	__idivs
	PUSH	HL
	LD	BC,211
	PUSH	BC
	LD	BC,81
	PUSH	BC
	CALL	_gfx_FillRectangle_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  467	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _displayLoadingBar ***************************
;Name                         Addr/Register   Size   Type
;_ti_GetSize                         IMPORT  -----   function
;_ice                                IMPORT  10958   variable
;_ti_Tell                            IMPORT  -----   function
;_gfx_FillRectangle_NoClip           IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


;  468	
;  469	int getNextToken(void) {
_getNextToken:
;  470	    return ti_GetC(ice.inPrgm);
	LD	A,(_ice+10904)
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_ti_GetC
	POP	BC
;  471	}
	RET	


;**************************** _getNextToken ***************************
;Name                         Addr/Register   Size   Type
;_ice                                IMPORT  10958   variable
;_ti_GetC                            IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  472	
;  473	int grabString(uint8_t **outputPtr, bool stopAtStoreAndString) {
_grabString:
	LD	HL,-20
	CALL	__frameset
;  474	    void *dataPtr = ti_GetDataPtr(ice.inPrgm);
	LD	A,(_ice+10904)
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_ti_GetDataPtr
	POP	BC
	LD	(IX+-17),HL
;  475	    uint24_t token;
;  476	
;  477	    while ((token = _getc()) != EOF && !(stopAtStoreAndString && ((uint8_t)token == tString || (uint8_t)token == tStore)) && (uint8_t)token != tEnter) {
	JR	L_240
L_241:
;  478	        uint24_t strLength, a;
;  479	        const char *dataString;
;  480	        uint8_t tokSize;
;  481	
;  482	        // Get the token in characters, and copy to the output
;  483	        dataString = ti_GetTokenString(&dataPtr, &tokSize, &strLength);
	PEA	IX+-11
	PEA	IX+-8
	PEA	IX+-17
	CALL	_ti_GetTokenString
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-20),HL
;  484	        memcpy(*outputPtr, dataString, strLength);
	LD	BC,(IX+-11)
	PUSH	BC
	LD	BC,(IX+-20)
	PUSH	BC
	LD	HL,(IX+6)
	LD	BC,(HL)
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  485	
;  486	        for (a = 0; a < strLength; a++) {
	LD	BC,0
	LD	(IX+-4),BC
	JR	L_237
L_235:
;  487	            uint8_t char2 = *(*outputPtr + a);
	LD	HL,(IX+6)
	LD	HL,(HL)
	LD	BC,(IX+-4)
	ADD	HL,BC
	LD	(IX+-14),HL
	LD	A,(HL)
	LD	(IX+-1),A
;  488	
;  489	            // Differences in TI-ASCII and ASCII set, C functions expect the normal ASCII set
;  490	            // There are no 4sqrt( and theta symbol in the first 128 characters of the ASCII set
;  491	            if (char2 == 0x24 || char2 == 0x5B) {
	CP	A,36
	JR	Z,L_226
	LD	A,(IX+-1)
	CP	A,91
	JR	NZ,L_228
L_226:
;  492	                char2 = 0;
	LD	(IX+-1),0
;  493	            }
L_228:
;  494	
;  495	            // $ = 0x24
;  496	            if (char2 == 0xF2) {
	LD	A,(IX+-1)
	CP	A,242
	JR	NZ,L_230
;  497	                char2 = 0x24;
	LD	(IX+-1),36
;  498	            }
L_230:
;  499	
;  500	            // [ = 0x5B
;  501	            if (char2 == 0xC1) {
	LD	A,(IX+-1)
	CP	A,193
	JR	NZ,L_233
;  502	                char2 = 0x5B;
	LD	(IX+-1),91
;  503	            }
L_233:
;  504	
;  505	            // All the first 32 and last 128 characters are different
;  506	            if (char2 < 32 || char2 > 127) {
	LD	A,(IX+-1)
	CP	A,32
	JR	C,L_232
	LD	A,127
	CP	A,(IX+-1)
	JR	NC,L_234
L_232:
;  507	                displayError(W_WRONG_CHAR);
	LD	BC,19
	PUSH	BC
	CALL	_displayError
	POP	BC
;  508	                char2 = 0;
	LD	(IX+-1),0
;  509	            }
L_234:
;  510	
;  511	            *(*outputPtr + a) = char2;
	LD	HL,(IX+-14)
	LD	A,(IX+-1)
	LD	(HL),A
	LD	BC,(IX+-4)
	INC	BC
	LD	(IX+-4),BC
;  512	        }
L_237:
	LD	BC,(IX+-11)
	LD	HL,(IX+-4)
	OR	A,A
	SBC	HL,BC
	JR	C,L_235
;  513	        
;  514	        *outputPtr += strLength;
	LD	HL,(IX+6)
	LD	HL,(HL)
	LD	BC,(IX+-11)
	ADD	HL,BC
	LD	IY,(IX+6)
	LD	(IY),HL
;  515	
;  516	        // If it's a 2-byte token, we also need to get the second byte of it
;  517	        if (tokSize == 2) {
	LD	A,(IX+-8)
	CP	A,2
	JR	NZ,L_240
;  518	            _getc();
	CALL	_getNextToken
;  519	        }
;  520	    }
L_240:
	CALL	_getNextToken
	LD	(IX+-7),HL
	LD	BC,16777215
	OR	A,A
	SBC	HL,BC
	JR	Z,L_242
	LD	A,(IX+9)
	OR	A,A
	JR	Z,L_223
	LD	A,(IX+-7)
	CP	A,42
	JR	Z,L_242
	LD	A,(IX+-7)
	CP	A,4
	JR	Z,L_242
L_223:
	LD	A,(IX+-7)
	CP	A,63
	JR	NZ,L_241
L_242:
;  521	
;  522	    return token;
	LD	HL,(IX+-7)
;  523	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _grabString ***************************
;Name                         Addr/Register   Size   Type
;_getNextToken                       IMPORT  -----   function
;_displayError                       IMPORT  -----   function
;_memcpy                             IMPORT  -----   function
;_ti_GetTokenString                  IMPORT  -----   function
;_ice                                IMPORT  10958   variable
;_ti_GetDataPtr                      IMPORT  -----   function
;dataString                           IX-20      3   variable
;dataPtr                              IX-17      3   variable
;G_4                                  IX-14      3   variable
;strLength                            IX-11      3   variable
;tokSize                               IX-8      1   variable
;token                                 IX-7      3   variable
;a                                     IX-4      3   variable
;char2                                 IX-1      1   variable
;stopAtStoreAndString                  IX+9      1   parameter
;outputPtr                             IX+6      3   parameter


; Stack Frame Size: 32 (bytes)
;       Spill Code: 0 (instruction)


;  524	
;  525	void printButton(uint24_t xPos) {
_printButton:
	CALL	__frameset0
;  526	    gfx_SetColor(0);
	LD	BC,0
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  527	    gfx_Rectangle_NoClip(xPos, 230, 40, 11);
	LD	BC,11
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,230
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_gfx_Rectangle_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  528	    gfx_SetPixel(xPos + 1, 231);
	LD	BC,231
	PUSH	BC
	LD	BC,(IX+6)
	INC	BC
	PUSH	BC
	CALL	_gfx_SetPixel
	POP	BC
	POP	BC
;  529	    gfx_SetPixel(xPos + 38, 231);
	LD	BC,231
	PUSH	BC
	LD	IY,(IX+6)
	LEA	BC,IY+38
	PUSH	BC
	CALL	_gfx_SetPixel
	POP	BC
	POP	BC
;  530	    gfx_SetColor(255);
	LD	BC,255
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  531	    gfx_SetPixel(xPos, 230);
	LD	BC,230
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_gfx_SetPixel
	POP	BC
	POP	BC
;  532	    gfx_SetPixel(xPos + 39, 230);
	LD	BC,230
	PUSH	BC
	LD	IY,(IX+6)
	LEA	BC,IY+39
	PUSH	BC
	CALL	_gfx_SetPixel
	POP	BC
	POP	BC
;  533	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _printButton ***************************
;Name                         Addr/Register   Size   Type
;_gfx_SetPixel                       IMPORT  -----   function
;_gfx_Rectangle_NoClip               IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function
;xPos                                  IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


	XREF _implementedFunctions:ROM
	XREF _displayError:ROM
	XREF _reg:ROM
	XREF _prescan:ROM
	XREF _expr:ROM
	XREF _ice:ROM
	XREF _gfx_ShiftUp:ROM
	XREF _gfx_SetClipRegion:ROM
	XREF _gfx_SetTextXY:ROM
	XREF _gfx_GetTextY:ROM
	XREF _gfx_GetTextX:ROM
	XREF _gfx_PrintChar:ROM
	XREF _gfx_FillRectangle_NoClip:ROM
	XREF _gfx_FillRectangle:ROM
	XREF _gfx_Rectangle_NoClip:ROM
	XREF _gfx_SetPixel:ROM
	XREF _gfx_SetColor:ROM
	XREF _strcmp:ROM
	XREF _strlen:ROM
	XREF _memchr:ROM
	XREF _memcpy:ROM
	XREF _ti_GetDataPtr:ROM
	XREF _ti_GetTokenString:ROM
	XREF _ti_GetSize:ROM
	XREF _ti_Tell:ROM
	XREF _ti_Seek:ROM
	XREF _ti_GetC:ROM
	XREF _malloc:ROM
	XREF __idivs:ROM
	XREF __imulu:ROM
	XREF __stoiu:ROM
	XREF __frameset0:ROM
	XREF __frameset:ROM
	XREF __setflag:ROM
	XREF __icmpzero:ROM
	XREF __imul_b:ROM
	XREF __ishru_b:ROM
	XDEF _printButton
	XDEF _grabString
	XDEF _getNextToken
	XDEF _displayLoadingBar
	XDEF _displayLoadingBarFrame
	XDEF _GetVariableOffset
	XDEF _CallRoutine
	XDEF _CheckEOL
	XDEF _IsHexadecimal
	XDEF _PushHLDE
	XDEF _MaybeLDIYFlags
	XDEF _displayMessageLineScroll
	XDEF _SeekMinus1
	XDEF _MaybeAToHL
	XDEF _RegChangeHLDE
	XDEF _ResetA
	XDEF _ResetBC
	XDEF _ResetDE
	XDEF _ResetHL
	XDEF _ResetAllRegs
	XDEF _LoadRegVariable
	XDEF _LoadRegValue
	XDEF _ChangeRegValue
	XDEF _ClearAnsFlags
	XDEF _SetRegDEToRegHL
	XDEF _SetRegHLToRegDE
	XDEF _AnsToA
	XDEF _AnsToBC
	XDEF _AnsToDE
	XDEF _AnsToHL
	XDEF _ProgramPtrToOffsetStack
	XDEF _GetProgramName
	XDEF _IsA2ByteTok
	XDEF _OutputWriteMem
	XDEF _OutputWriteLong
	XDEF _OutputWriteWord
	XDEF _OutputWriteByte
	XDEF _GetIndexOfFunction
	END
