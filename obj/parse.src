; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"..\SRC\PARSE.C"
	.assume ADL=1
	SEGMENT BSS
_outputStack:
	DS	2400
_stack:
	DS	300
;    1	#include "defines.h"
;    2	#include "parse.h"
;    3	
;    4	#include "ast.h"
;    5	#include "operator.h"
;    6	#include "main.h"
;    7	#include "functions.h"
;    8	#include "errors.h"
;    9	#include "stack.h"
;   10	#include "output.h"
;   11	#include "routines.h"
;   12	#include "prescan.h"
;   13	
;   14	#ifndef CALCULATOR
;   15	extern const uint8_t PauseData[];
;   16	extern const uint8_t InputData[];
;   17	extern const uint8_t PrgmData[];
;   18	extern const uint8_t DispData[];
;   19	extern const uint8_t RandData[];
;   20	
;   21	extern char *str_dupcat(const char *s, const char *c);
;   22	#endif
;   23	
;   24	static uint8_t (*functions[256])(int token);
;   25	extern const function_t implementedFunctions[AMOUNT_OF_FUNCTIONS];
;   26	element_t outputStack[400];
;   27	element_t stack[50];
	SEGMENT CODE
;   28	
;   29	uint8_t parseProgram(void) {
_parseProgram:
	LD	HL,-46
	CALL	__frameset
;   30	    uint8_t currentGoto, currentLbl, ret, *randAddr;
;   31	    
;   32	    LD_IX_IMM(IX_VARIABLES);
	LD	BC,8669
	PUSH	BC
	CALL	_OutputWriteWord
	POP	BC
	LD	BC,13713223
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
;   33	    
;   34	    _seek(0, SEEK_END, ice.inPrgm);
	LD	A,(_ice+10904)
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_ti_Seek
	POP	BC
	POP	BC
	POP	BC
;   35	    if (!_tell(ice.inPrgm)) {
	LD	A,(_ice+10904)
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_ti_Tell
	POP	BC
	CALL	__scmpzero
	JR	NZ,L_4
;   36	        return VALID;
	LD	A,255
	JR	L_41
;   37	    }
L_4:
;   38	    _rewind(ice.inPrgm);
	LD	A,(_ice+10904)
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_ti_Rewind
	POP	BC
;   39	    
;   40	    // Eventually seed the rand
;   41	    if (prescan.amountOfRandRoutines) {
	LD	A,(_prescan+7)
	OR	A,A
	JR	Z,L_21
;   42	        ice.programDataPtr -= SIZEOF_RAND_DATA;
	LD	IY,(_ice+66)
	LEA	BC,IY+-118
	LD	(_ice+66),BC
;   43	        randAddr = ice.programDataPtr;
	LD	(IX+-10),BC
;   44	        ice.randAddr = (uint24_t)randAddr;
;   45	        memcpy(ice.programDataPtr, RandData, SIZEOF_RAND_DATA);
	LD	DE,118
	PUSH	DE
	LD	(_ice+10911),BC
	LD	BC,_RandData
	PUSH	BC
	LD	BC,(_ice+66)
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;   46	        
;   47	        // Write internal pointers
;   48	        ice.dataOffsetStack[ice.dataOffsetElements++] = (uint24_t*)(randAddr + 2);
	LD	IY,(IX+-10)
	LEA	DE,IY+2
	LD	BC,(_ice+3077)
	LD	(IX+-46),DE
	LD	DE,_ice+77
	LD	(IX+-43),DE
	LD	HL,3
	CALL	__imulu
	LD	BC,(IX+-43)
	ADD	HL,BC
	LD	BC,(IX+-46)
	LD	(HL),BC
	LD	BC,(_ice+3077)
	INC	BC
	LD	(_ice+3077),BC
;   49	        w24(randAddr + 2, ice.randAddr + 102);
	LD	IY,(_ice+10911)
	LEA	BC,IY+102
	LD	HL,(IX+-46)
	LD	(HL),BC
;   50	        ice.dataOffsetStack[ice.dataOffsetElements++] = (uint24_t*)(randAddr + 6);
	LD	IY,(IX+-10)
	LEA	DE,IY+6
	LD	BC,(_ice+3077)
	LD	(IX+-40),DE
	LD	HL,3
	CALL	__imulu
	LD	BC,(IX+-43)
	ADD	HL,BC
	LD	BC,(IX+-40)
	LD	(HL),BC
	LD	BC,(_ice+3077)
	INC	BC
	LD	(_ice+3077),BC
;   51	        w24(randAddr + 6, ice.randAddr + 105);
	LD	IY,(_ice+10911)
	LEA	BC,IY+105
	LD	HL,(IX+-40)
	LD	(HL),BC
;   52	        ice.dataOffsetStack[ice.dataOffsetElements++] = (uint24_t*)(randAddr + 19);
	LD	IY,(IX+-10)
	LEA	DE,IY+19
	LD	BC,(_ice+3077)
	LD	(IX+-37),DE
	LD	HL,3
	CALL	__imulu
	LD	BC,(IX+-43)
	ADD	HL,BC
	LD	BC,(IX+-37)
	LD	(HL),BC
	LD	BC,(_ice+3077)
	INC	BC
	LD	(_ice+3077),BC
;   53	        w24(randAddr + 19, ice.randAddr + 102);
	LD	HL,(IX+-37)
	LD	IY,(_ice+10911)
;   54	
;   55	        // Call seed rand
;   56	        LD_HL_IND(0xF30044);
	LD	BC,42
	PUSH	BC
	LEA	BC,IY+102
	LD	(HL),BC
	CALL	_OutputWriteByte
	POP	BC
	LD	BC,15925316
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
	CALL	_ResetHL
;   57	        ProgramPtrToOffsetStack();
	CALL	_ProgramPtrToOffsetStack
;   58	        CALL((uint24_t)ice.programDataPtr);
	LD	BC,205
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	BC,(_ice+66)
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
;   59	    }
L_21:
;   60	    
;   61	    // Open debug appvar to store things to
;   62	#ifdef CALCULATOR
;   63	    if (ice.debug) {
	LD	A,(_ice+10909)
	OR	A,A
	JR	Z,L_23
;   64	        char buf[21];
;   65	        uint8_t curVar;
;   66	        
;   67	        sprintf(buf, "%.5sDBG", ice.outName);
	LD	BC,_ice
	PUSH	BC
	LD	BC,L__3
	PUSH	BC
	PEA	IX+-34
	CALL	_sprintf
	POP	BC
	POP	BC
	POP	BC
;   68	        if (!(ice.dbgPrgm = ti_Open(buf, "w"))) {
	LD	BC,L__4
	PUSH	BC
	PEA	IX+-34
	CALL	_ti_Open
	POP	BC
	POP	BC
	LD	(_ice+10906),A
	OR	A,A
	JR	NZ,L_15
;   69	            return E_NO_DBG_FILE;
	LD	A,16
	JR	L_41
;   70	        }
L_15:
;   71	        
;   72	        // Write all variables to debug appvar
;   73	        sprintf(buf, "%s\x00", ice.currProgName[ice.inPrgm]);
	LD	A,(_ice+10904)
	UEXT	HL
	LD	L,A
	LD	A,9
	CALL	__imul_b
	LD	BC,_ice+9
	ADD	HL,BC
	PUSH	HL
	LD	BC,L__6
	PUSH	BC
	PEA	IX+-34
	CALL	_sprintf
	POP	BC
	POP	BC
	POP	BC
;   74	        ti_Write(buf, strlen(buf) + 1, 1, ice.dbgPrgm);
	LD	A,(_ice+10906)
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PEA	IX+-34
	CALL	_strlen
	POP	BC
	INC	HL
	PUSH	HL
	PEA	IX+-34
	CALL	_ti_Write
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;   75	        ti_PutC(prescan.amountOfVariablesUsed, ice.dbgPrgm);
	LD	A,(_ice+10906)
	LD	C,A
	LD	A,(_prescan+18)
	LD	B,0
	PUSH	BC
	LD	C,A
	PUSH	BC
	CALL	_ti_PutC
	POP	BC
	POP	BC
;   76	        for (curVar = 0; curVar < prescan.amountOfVariablesUsed; curVar++) {
	LD	(IX+-3),0
	JR	L_19
L_17:
;   77	            sprintf(buf, "%s\x00", prescan.variables[curVar].name);
	LD	A,(IX+-3)
	UEXT	HL
	LD	L,A
	LD	A,21
	CALL	__imul_b
	LD	BC,_prescan+478
	ADD	HL,BC
	LD	IY,HL
	PEA	IY+0
	LD	BC,L__7
	PUSH	BC
	PEA	IX+-34
	CALL	_sprintf
	POP	BC
	POP	BC
	POP	BC
;   78	            ti_Write(buf, strlen(buf) + 1, 1, ice.dbgPrgm);
	LD	A,(_ice+10906)
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PEA	IX+-34
	CALL	_strlen
	POP	BC
	INC	HL
	PUSH	HL
	PEA	IX+-34
	CALL	_ti_Write
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	INC	(IX+-3)
;   79	        }
L_19:
	LD	A,(IX+-3)
	LD	HL,_prescan+18
	CP	A,(HL)
	JR	C,L_17
;   80	    }
L_23:
;   81	#endif
;   82	
;   83	    if ((ret = parseProgramUntilEnd()) != VALID) {
	CALL	_parseProgramUntilEnd
	LD	(IX+-4),A
	CP	A,255
	JR	Z,L_27
;   84	        return ret;
	LD	A,(IX+-4)
	JR	L_41
;   85	    }
L_27:
;   86	    
;   87	    if (!ice.lastTokenIsReturn) {
	LD	A,(_ice+10907)
	OR	A,A
	JR	NZ,L_39
;   88	        RET();
	LD	BC,201
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;   89	    }
L_39:
;   90	    
;   91	    // Find all the matching Goto's/Lbl's
;   92	    for (currentGoto = 0; currentGoto < ice.curGoto; currentGoto++) {
	LD	(IX+-1),0
	JR	L_38
L_36:
;   93	        label_t *curGoto = &ice.GotoStack[currentGoto];
	LD	A,(IX+-1)
	LD	BC,(_ice+74)
	UEXT	HL
	LD	L,A
	LD	A,26
	CALL	__imul_b
	ADD	HL,BC
	LD	(IX+-7),HL
;   94	
;   95	        for (currentLbl = 0; currentLbl < ice.curLbl; currentLbl++) {
	LD	(IX+-2),0
	JR	L_34
L_32:
;   96	            label_t *curLbl = &ice.LblStack[currentLbl];
	LD	A,(IX+-2)
	UEXT	HL
	LD	L,A
	LD	A,26
	CALL	__imul_b
	LD	BC,(_ice+71)
	ADD	HL,BC
	LD	(IX+-13),HL
;   97	
;   98	            if (!memcmp(curLbl->name, curGoto->name, 20)) {
	LD	BC,20
	PUSH	BC
	LD	IY,(IX+-7)
	PEA	IY+0
	LD	IY,(IX+-13)
	PEA	IY+0
	CALL	_memcmp
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_33
;   99	                w24(curGoto->addr + 1, (uint24_t)curLbl->addr - (uint24_t)ice.programData + PRGM_START);
	LD	IY,(IX+-13)
	LD	HL,(IY+20)
	LD	BC,(_ice+54)
	LD	IY,(IX+-7)
	OR	A,A
	SBC	HL,BC
	LD	IY,(IY+20)
	LD	BC,13740162
	ADD	HL,BC
	LD	(IY+1),HL
;  100	                goto findNextLabel;
	JR	L_30
;  101	            }
;  102	        }
L_33:
	INC	(IX+-2)
L_34:
	LD	A,(IX+-2)
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,(_ice+10895)
	SBC	HL,BC
	JR	C,L_32
;  103	
;  104	        // Label not found
;  105	        displayLabelError(curGoto->name);
	LD	IY,(IX+-7)
	PEA	IY+0
	CALL	_displayLabelError
	POP	BC
;  106	        _seek(curGoto->offset, SEEK_SET, ice.inPrgm);
	LD	A,(_ice+10904)
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	IY,(IX+-7)
	LD	BC,(IY+23)
	PUSH	BC
	CALL	_ti_Seek
	POP	BC
	POP	BC
	POP	BC
;  107	        
;  108	        return W_VALID;
	LD	A,254
	JR	L_41
L_30:
	INC	(IX+-1)
;  109	findNextLabel:;
;  110	    }
L_38:
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,(_ice+10898)
	SBC	HL,BC
	JR	C,L_36
;  111	    
;  112	    return VALID;
	LD	A,255
;  113	}
L_41:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _parseProgram ***************************
;Name                         Addr/Register   Size   Type
;_displayLabelError                  IMPORT  -----   function
;_memcmp                             IMPORT  -----   function
;_parseProgramUntilEnd               IMPORT  -----   function
;_ti_PutC                            IMPORT  -----   function
;_strlen                             IMPORT  -----   function
;_ti_Write                           IMPORT  -----   function
;_ti_Open                            IMPORT  -----   function
;_sprintf                            IMPORT  -----   function
;_ProgramPtrToOffsetStack            IMPORT  -----   function
;_ResetHL                            IMPORT  -----   function
;_OutputWriteByte                    IMPORT  -----   function
;_RandData                           IMPORT  -----   function
;_memcpy                             IMPORT  -----   function
;_prescan                            IMPORT   5833   variable
;_ti_Rewind                          IMPORT  -----   function
;_ti_Tell                            IMPORT  -----   function
;_ice                                IMPORT  10958   variable
;_ti_Seek                            IMPORT  -----   function
;_OutputWriteLong                    IMPORT  -----   function
;_OutputWriteWord                    IMPORT  -----   function
;buf                                  IX-34     21   variable
;curLbl                               IX-13      3   variable
;randAddr                             IX-10      3   variable
;curGoto                               IX-7      3   variable
;ret                                   IX-4      1   variable
;curVar                                IX-3      1   variable
;currentLbl                            IX-2      1   variable
;currentGoto                           IX-1      1   variable


; Stack Frame Size: 52 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__3:
	DB	"%.5sDBG"
	DB	0
L__4:
	DB	"w"
	DB	0
L__6:
	DB	"%s"
	DB	0,0
L__7:
	DB	"%s"
	DB	0,0
	SEGMENT CODE
;  114	
;  115	uint8_t parseProgramUntilEnd(void) {
_parseProgramUntilEnd:
	LD	HL,-4
	CALL	__frameset
;  116	    int token;
;  117	    
;  118	    // Do things based on the token
;  119	    while ((token = _getc()) != EOF) {
	JR	L_45
L_46:
;  120	        uint8_t ret;
;  121	        
;  122	        ice.lastTokenIsReturn = false;
	XOR	A,A
	LD	(_ice+10907),A
;  123	        ice.currentLine++;
	LD	BC,(_ice+3386)
	INC	BC
	LD	(_ice+3386),BC
;  124	        
;  125	        if ((ret = (*functions[token])(token)) != VALID) {
	LD	HL,(IX+-4)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_functions
	ADD	HL,BC
	LD	BC,(IX+-4)
	PUSH	BC
	LD	IY,(HL)
	CALL	__indcall
	POP	BC
	LD	(IX+-1),A
	CP	A,255
	JR	Z,L_44
;  126	            return ret;
	LD	A,(IX+-1)
	JR	L_48
;  127	        }
L_44:
;  128	
;  129	#ifdef CALCULATOR
;  130	        displayLoadingBar();
	CALL	_displayLoadingBar
;  131	#endif
;  132	    }
L_45:
	CALL	_getNextToken
	LD	(IX+-4),HL
	LD	BC,16777215
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_46
;  133	    
;  134	    return VALID;
	LD	A,255
;  135	}
L_48:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _parseProgramUntilEnd ***************************
;Name                         Addr/Register   Size   Type
;_getNextToken                       IMPORT  -----   function
;_displayLoadingBar                  IMPORT  -----   function
;_functions                          STATIC    768   variable
;_ice                                IMPORT  10958   variable
;token                                 IX-4      3   variable
;ret                                   IX-1      1   variable


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


;  136	
;  137	uint8_t parseExpression(int token) {
_parseExpression:
	LD	HL,-182
	CALL	__frameset
;  138	    NODE *outputNode = NULL;
;  139	    NODE *stackNode = NULL;
;  140	    uint24_t stackElements = 0, outputElements = 0;
	LD	BC,0
	LD	(IX+-10),BC
	LD	(IX+-3),BC
;  141	    uint24_t loopIndex, temp;
;  142	    uint8_t amountOfArgumentsStack[20];
;  143	    uint8_t index = 0, a, stackToOutputReturn, mask = TYPE_MASK_U24, tok, storeDepth = 0;
	LD	(IX+-27),0
	LD	(IX+-11),2
	LD	(IX+-36),0
;  144	    uint8_t *amountOfArgumentsStackPtr = amountOfArgumentsStack, canUseMask = 2, prevTokenWasCFunction = 0;
	LD	HL,IX
	LD	BC,-155
	ADD	HL,BC
	LD	(IX+-17),HL
	LD	(IX+-28),2
	LD	(IX+-40),0
;  145	
;  146	    // Setup pointers
;  147	    element_t *outputPtr = outputStack;
	LD	BC,_outputStack
	LD	(IX+-31),BC
;  148	    element_t *stackPtr  = stack;
	LD	BC,_stack
	LD	(IX+-39),BC
;  149	    element_t *outputCurr, *outputPrev, *outputPrevPrev;
;  150	    element_t *stackCurr, *stackPrev = NULL;
;  151	    
;  152	    memset(&outputStack, 0, sizeof(outputStack));
	LD	BC,2400
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_outputStack
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  153	    memset(&stack, 0, sizeof(stack));
	LD	BC,300
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_stack
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  154	
;  155	    while (token != EOF && (tok = (uint8_t)token) != tEnter && tok != tColon) {
	JR	L_262
;  156	fetchNoNewToken:
L_51:
;  157	        outputCurr = &outputPtr[outputElements];
	LD	HL,(IX+-3)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	LD	BC,(IX+-31)
	ADD	HL,BC
	LD	(IX+-6),HL
;  158	        stackCurr  = &stackPtr[stackElements];
	LD	HL,(IX+-10)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	LD	BC,(IX+-39)
	ADD	HL,BC
	LD	(IX+-26),HL
;  159	
;  160	        // We can use the unsigned mask * only at the start of the line, or directly after an operator
;  161	        if (canUseMask) {
	LD	A,(IX+-28)
	OR	A,A
	JR	Z,L_56
;  162	            canUseMask--;
	DEC	(IX+-28)
;  163	        }
L_56:
;  164	
;  165	        // If there's a pointer directly after an -> operator, we have to ignore it
;  166	        if (storeDepth) {
	LD	A,(IX+-36)
	OR	A,A
	JR	Z,L_59
;  167	            storeDepth--;
	DEC	(IX+-36)
;  168	        }
L_59:
;  169	
;  170	        // If the previous token was a det( or a sum(, we need to store the next number in the stack entry too, to catch 'small arguments'
;  171	        if (prevTokenWasCFunction) {
	LD	A,(IX+-40)
	OR	A,A
	JR	Z,L_260
;  172	            prevTokenWasCFunction--;
	DEC	(IX+-40)
;  173	        }
L_260:
;  174	        
;  175	        // Process a number
;  176	        if (tok >= t0 && tok <= t9) {
	LD	A,(IX+-7)
	CP	A,48
	JR	C,L_259
	LD	A,57
	CP	A,(IX+-7)
	JR	C,L_259
;  177	            uint24_t output = token - t0;
	LD	IY,(IX+6)
	LEA	IY,IY+-48
	LD	(IX+-70),IY
;  178	
;  179	            while ((uint8_t)(token = _getc()) >= t0 && (uint8_t)token <= t9) {
	JR	L_62
L_63:
;  180	                output = output * 10 + token - t0;
	LD	HL,(IX+-70)
	LD	BC,(IX+6)
	LD	A,10
	CALL	__imul_b
	ADD	HL,BC
	LD	IY,HL
	LEA	IY,IY+-48
	LD	(IX+-70),IY
;  181	            }
L_62:
	CALL	_getNextToken
	LD	(IX+6),HL
	LD	A,(IX+6)
	CP	A,48
	JR	C,L_64
	LD	B,(IX+6)
	LD	A,57
	CP	A,B
	JR	NC,L_63
L_64:
;  182	            outputCurr->type = TYPE_NUMBER;
	LD	IY,(IX+-6)
	LD	(IY+1),0
;  183	            outputCurr->operand.num = output;
	LD	BC,(IX+-70)
	LD	(IY+3),BC
;  184	            outputElements++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  185	            mask = TYPE_MASK_U24;
	LD	(IX+-11),2
;  186	
;  187	            if (prevTokenWasCFunction) {
	LD	A,(IX+-40)
	OR	A,A
	JR	Z,L_262
;  188	                stackPtr[stackElements - 1].operand.func.function2 = output;
	LD	A,(IX+-70)
	LD	IY,(IX+-10)
	LEA	HL,IY+-1
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	LD	BC,(IX+-39)
	ADD	HL,BC
	LD	IY,HL
	LD	(IY+5),A
;  189	            }
;  190	
;  191	            // Don't grab a new token
;  192	            continue;
	JR	L_262
;  193	        }
;  194	
;  195	        // Process a hexadecimal number
;  196	        else if (tok == tee) {
L_259:
	LD	A,(IX+-7)
	CP	A,59
	JR	NZ,L_257
;  197	            uint24_t output = 0;
	LD	BC,0
	LD	(IX+-87),BC
;  198	
;  199	            while ((tok = IsHexadecimal(token = _getc())) != 16) {
	JR	L_68
L_69:
;  200	                output = (output << 4) + tok;
	LD	HL,(IX+-87)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	A,(IX+-7)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	(IX+-87),HL
;  201	            }
L_68:
	CALL	_getNextToken
	LD	(IX+6),HL
	LD	BC,HL
	PUSH	BC
	CALL	_IsHexadecimal
	POP	BC
	LD	(IX+-7),A
	CP	A,16
	JR	NZ,L_69
;  202	            outputCurr->type = TYPE_NUMBER;
	LD	IY,(IX+-6)
	LD	(IY+1),0
;  203	            outputCurr->operand.num = output;
	LD	BC,(IX+-87)
	LD	(IY+3),BC
;  204	            outputElements++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  205	            mask = TYPE_MASK_U24;
	LD	(IX+-11),2
;  206	
;  207	            // Don't grab a new token
;  208	            continue;
	JR	L_262
;  209	        }
;  210	
;  211	        // Process a binary number
;  212	        else if (tok == tPi) {
L_257:
	LD	A,(IX+-7)
	CP	A,172
	JR	NZ,L_255
;  213	            uint24_t output = 0;
	LD	BC,0
	LD	(IX+-90),BC
;  214	
;  215	            while ((tok = (token = _getc())) >= t0 && tok <= t1) {
	JR	L_73
L_74:
;  216	                output = (output << 1) + tok - t0;
	LD	HL,(IX+-90)
	ADD	HL,HL
	LD	BC,HL
	LD	A,(IX+-7)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,HL
	LEA	IY,IY+-48
	LD	(IX+-90),IY
;  217	            }
L_73:
	CALL	_getNextToken
	LD	(IX+6),HL
	LD	A,(IX+6)
	LD	(IX+-7),A
	CP	A,48
	JR	C,L_75
	LD	A,49
	CP	A,(IX+-7)
	JR	NC,L_74
L_75:
;  218	            outputCurr->type = TYPE_NUMBER;
	LD	IY,(IX+-6)
	LD	(IY+1),0
;  219	            outputCurr->operand.num = output;
	LD	BC,(IX+-90)
	LD	(IY+3),BC
;  220	            outputElements++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  221	            mask = TYPE_MASK_U24;
	LD	(IX+-11),2
;  222	
;  223	            // Don't grab a new token
;  224	            continue;
	JR	L_262
;  225	        }
;  226	
;  227	        // Process a 'negative' number or expression
;  228	        else if (tok == tChs) {
L_255:
	LD	A,(IX+-7)
	CP	A,176
	JR	NZ,L_253
;  229	            if ((token = _getc()) >= t0 && token <= t9) {
	CALL	_getNextToken
	LD	(IX+6),HL
	LD	BC,48
	OR	A,A
	SBC	HL,BC
	JP	M,L_86
	LD	BC,(IX+6)
	LD	HL,57
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_86
;  230	                uint24_t output = token - t0;
	LD	IY,(IX+6)
	LEA	IY,IY+-48
	LD	(IX+-81),IY
;  231	
;  232	                while ((uint8_t)(token = _getc()) >= t0 && (uint8_t)token <= t9) {
	JR	L_79
L_80:
;  233	                    output = output * 10 + token - t0;
	LD	HL,(IX+-81)
	LD	BC,(IX+6)
	LD	A,10
	CALL	__imul_b
	ADD	HL,BC
	LD	IY,HL
	LEA	IY,IY+-48
	LD	(IX+-81),IY
;  234	                }
L_79:
	CALL	_getNextToken
	LD	(IX+6),HL
	LD	A,(IX+6)
	CP	A,48
	JR	C,L_81
	LD	B,(IX+6)
	LD	A,57
	CP	A,B
	JR	NC,L_80
L_81:
;  235	                outputCurr->type = TYPE_NUMBER;
	LD	IY,(IX+-6)
	LD	(IY+1),0
;  236	                outputCurr->operand.num = 0-output;
	LD	HL,(IX+-81)
	CALL	__ineg
	LD	(IY+3),HL
;  237	                outputElements++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  238	                mask = TYPE_MASK_U24;
	LD	(IX+-11),2
;  239	
;  240	                // Don't grab a new token
;  241	                continue;
	JR	L_262
;  242	            } else {
L_86:
;  243	                // Pretend as if it's a -1*
;  244	                outputCurr->type = TYPE_NUMBER;
	LD	IY,(IX+-6)
	LD	(IY+1),0
;  245	                outputCurr->operand.num = -1;
	LD	BC,16777215
	LD	(IY+3),BC
;  246	                outputElements++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  247	                SeekMinus1();
	CALL	_SeekMinus1
;  248	                tok = tMul;
;  249	                goto tokenIsOperator;
	JR	L_114
;  250	            }
;  251	        }
;  252	
;  253	        // Process an OS list (number or list element)
;  254	        else if (tok == tVarLst) {
L_253:
	LD	A,(IX+-7)
	CP	A,93
	JR	NZ,L_251
;  255	            outputCurr->type = TYPE_NUMBER;
	LD	IY,(IX+-6)
	LD	(IY+1),0
;  256	            outputCurr->operand.num = prescan.OSLists[_getc()];
	CALL	_getNextToken
	LD	BC,HL
	LD	HL,3
	CALL	__imulu
	LD	BC,_prescan+439
	ADD	HL,BC
	LD	BC,(HL)
	LD	IY,(IX+-6)
	LD	(IY+3),BC
;  257	            outputElements++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  258	            mask = TYPE_MASK_U24;
	LD	(IX+-11),2
;  259	
;  260	            // Check if it's a list element
;  261	            if ((uint8_t)(token = _getc()) == tLParen) {
	CALL	_getNextToken
	LD	(IX+6),HL
	LD	A,(IX+6)
	CP	A,16
	JR	NZ,L_262
;  262	                // Trick ICE to think it's a {L1+...}
;  263	                *++amountOfArgumentsStackPtr = 1;
	LD	BC,(IX+-17)
	INC	BC
	LD	(IX+-17),BC
	LD	HL,BC
	LD	(HL),1
;  264	                stackCurr->type = TYPE_FUNCTION;
	LD	IY,(IX+-26)
	LD	(IY+1),127
;  265	                stackCurr->mask = mask;
	LD	(IY+2),2
;  266	
;  267	                // I have to create a non-existent token, because L1(...) the right parenthesis should pretend it's a },
;  268	                // but that is impossible if I just push { or (. Then when a ) appears and it hits the 0x0F, just replace it with a }
;  269	                stackCurr->operand.func.function = 0x0F;
	LD	(IY+3),15
;  270	                stackCurr->operand.func.function2 = storeDepth && 1;
	LD	A,(IX+-36)
	OR	A,A
	JR	Z,L_90
	LD	BC,1
	LD	(IX+-120),BC
	JR	L_91
L_90:
	LD	BC,0
	LD	(IX+-120),BC
L_91:
	LD	A,(IX+-120)
	LD	IY,(IX+-26)
	LD	(IY+5),A
;  271	                stackElements++;
	LD	BC,(IX+-10)
	INC	BC
	LD	(IX+-10),BC
;  272	                mask = TYPE_MASK_U24;
	LD	(IX+-11),2
;  273	                canUseMask = 2;
	LD	(IX+-28),2
;  274	
;  275	                // :D
;  276	                token = tAdd;
	LD	BC,112
	LD	(IX+6),BC
;  277	            }
;  278	
;  279	            // Don't grab next token
;  280	            continue;
	JR	L_262
;  281	        }
;  282	
;  283	        // Process a variable
;  284	        else if (tok >= tA && tok <= tTheta) {
L_251:
	LD	A,(IX+-7)
	CP	A,65
	JR	C,L_249
	LD	A,91
	CP	A,(IX+-7)
	JR	C,L_249
;  285	            outputCurr->type = TYPE_VARIABLE;
	LD	IY,(IX+-6)
	LD	(IY+1),1
;  286	            outputCurr->operand.var = GetVariableOffset(tok);
	LD	C,(IX+-7)
	LD	B,0
	PUSH	BC
	CALL	_GetVariableOffset
	POP	BC
	LD	IY,(IX+-6)
	LD	(IY+3),A
;  287	            outputElements++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  288	            mask = TYPE_MASK_U24;
	LD	(IX+-11),2
;  289	        }
;  290	
;  291	        // Process a mask
;  292	        else if (tok == tMul && canUseMask) {
	JR	L_227
L_249:
	LD	A,(IX+-7)
	CP	A,130
	JR	NZ,L_247
	LD	A,(IX+-28)
	OR	A,A
	JR	Z,L_247
;  293	            uint8_t a = 0;
	LD	(IX+-47),0
;  294	
;  295	            while ((uint8_t)(token = _getc()) == tMul) {
	JR	L_100
L_101:
;  296	                a++;
	INC	(IX+-47)
;  297	            }
L_100:
	CALL	_getNextToken
	LD	(IX+6),HL
	LD	A,(IX+6)
	CP	A,130
	JR	Z,L_101
;  298	            if (a > 2 || (uint8_t)token != tLBrace) {
	LD	A,2
	CP	A,(IX+-47)
	JR	C,L_103
	LD	A,(IX+6)
	CP	A,8
	JR	Z,L_105
L_103:
;  299	                return E_SYNTAX;
	LD	A,6
	JR	L_333
;  300	            }
L_105:
;  301	            mask = TYPE_MASK_U8 + a;
	LD	A,(IX+-47)
	LD	(IX+-11),A
;  302	
;  303	            // If the previous token was a ->, remind it, if not, this won't hurt
;  304	            storeDepth++;
	INC	(IX+-36)
;  305	
;  306	            // Don't grab the { token
;  307	            continue;
	JR	L_262
;  308	        }
;  309	
;  310	        // Parse an operator
;  311	        else if ((index = getIndexOfOperator(tok))) {
L_247:
	LD	C,(IX+-7)
	LD	B,0
	PUSH	BC
	CALL	_getIndexOfOperator
	POP	BC
	LD	(IX+-27),A
	OR	A,A
	JR	Z,L_245
;  312	            // If the token is ->, move the entire stack to the output, instead of checking the precedence
;  313	            if (tok == tStore) {
	LD	A,(IX+-7)
	CP	A,4
	JR	NZ,L_114
;  314	                storeDepth = 2;
	LD	(IX+-36),2
;  315	                // Move entire stack to output
;  316	                stackToOutputReturn = 1;
	LD	(IX+-71),1
;  317	                goto stackToOutput;
	JR	L_328
;  318	            }
;  319	tokenIsOperator:
;  320	
;  321	            // Move the stack to the output as long as it's not empty
;  322	            while (stackElements) {
L_115:
;  323	                stackPrev = &stackPtr[stackElements-1];
	LD	IY,(IX+-10)
	LEA	BC,IY+-1
	LD	HL,6
	CALL	__imulu
	LD	(IX+-96),BC
	LD	(IX+-99),HL
	LD	BC,(IX+-39)
	ADD	HL,BC
	LD	(IX+-14),HL
;  324	
;  325	                // Move the last entry of the stack to the ouput if it's precedence is greater than the precedence of the current token
;  326	                if (stackPrev->type == TYPE_OPERATOR && operatorPrecedence[index - 1] <= operatorPrecedence2[getIndexOfOperator(stackPrev->operand.op) - 1]) {
	LD	IY,(IX+-14)
	LD	A,(IY+1)
	CP	A,126
	JR	NZ,L_117
	LD	IY,(IX+-14)
	LD	C,(IY+3)
	LD	B,0
	PUSH	BC
	CALL	_getIndexOfOperator
	POP	BC
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	BC,_operatorPrecedence2
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IX+-27)
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	BC,_operatorPrecedence
	ADD	HL,BC
	LD	A,(IY)
	CP	A,(HL)
	JR	C,L_117
;  327	                    memcpy(&outputPtr[outputElements], &stackPtr[stackElements-1], sizeof(element_t));
	LD	BC,6
	PUSH	BC
	LD	BC,(IX+-99)
	LD	HL,(IX+-39)
	ADD	HL,BC
	PUSH	HL
	LD	HL,(IX+-3)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	LD	BC,(IX+-31)
	ADD	HL,BC
	PUSH	HL
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  328	                    stackElements--;
	LD	BC,(IX+-96)
	LD	(IX+-10),BC
;  329	                    outputElements++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  330	                } else {
;  331	                    break;
;  332	                }
;  333	            }
L_114:
	LD	HL,(IX+-10)
	CALL	__icmpzero
	JR	NZ,L_115
L_119:
;  334	
;  335	stackToOutputReturn1:
L_117:
;  336	            // Push the operator to the stack
;  337	            stackCurr = &stackPtr[stackElements++];
	LD	HL,6
	LD	BC,(IX+-10)
	CALL	__imulu
	LD	BC,(IX+-39)
	ADD	HL,BC
	LD	(IX+-26),HL
	LD	BC,(IX+-10)
	INC	BC
	LD	(IX+-10),BC
;  338	            stackCurr->type = TYPE_OPERATOR;
	LD	IY,(IX+-26)
	LD	(IY+1),126
;  339	            stackCurr->operand.op = token;
	LD	A,(IX+6)
	LD	(IY+3),A
;  340	            mask = TYPE_MASK_U24;
	LD	(IX+-11),2
;  341	            canUseMask = 2;
	LD	(IX+-28),2
;  342	        }
;  343	
;  344	        // Gets the address of a variable
;  345	        else if (tok == tFromDeg) {
	JR	L_227
L_245:
	LD	A,(IX+-7)
	CP	A,11
	JR	NZ,L_243
;  346	            outputCurr->type = TYPE_NUMBER;
	LD	IY,(IX+-6)
	LD	(IY+1),0
;  347	            outputElements++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  348	            mask = TYPE_MASK_U24;
	LD	(IX+-11),2
;  349	            tok = _getc();
	CALL	_getNextToken
	LD	(IX+-7),L
;  350	
;  351	            // Get the address of the variable
;  352	            if (tok >= tA && tok <= tTheta) {
	LD	A,(IX+-7)
	CP	A,65
	JR	C,L_127
	LD	A,91
	CP	A,(IX+-7)
	JR	C,L_127
;  353	                outputCurr->operand.num = IX_VARIABLES + (char)GetVariableOffset(tok);
	LD	C,(IX+-7)
	LD	B,0
	PUSH	BC
	CALL	_GetVariableOffset
	POP	BC
	LD	IY,(IX+-6)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,13713223
	ADD	HL,BC
	LD	(IY+3),HL
;  354	            } else if (tok == tVarLst) {
	JR	L_227
L_127:
	LD	A,(IX+-7)
	CP	A,93
	JR	NZ,L_125
;  355	                outputCurr->operand.num = prescan.OSLists[_getc()];
	CALL	_getNextToken
	LD	BC,HL
	LD	HL,3
	CALL	__imulu
	LD	BC,_prescan+439
	ADD	HL,BC
	LD	BC,(HL)
	LD	IY,(IX+-6)
	LD	(IY+3),BC
;  356	            } else if (tok == tVarStrng) {
	JR	L_227
L_125:
	LD	A,(IX+-7)
	CP	A,170
	JR	NZ,L_123
;  357	                outputCurr->operand.num = prescan.OSStrings[_getc()];
	CALL	_getNextToken
	LD	BC,HL
	LD	HL,3
	CALL	__imulu
	LD	BC,_prescan+409
	ADD	HL,BC
	LD	BC,(HL)
	LD	IY,(IX+-6)
	LD	(IY+3),BC
;  358	            } else {
	JR	L_227
L_123:
;  359	                return E_SYNTAX;
	LD	A,6
	JR	L_333
;  360	            }
;  361	        }
;  362	
;  363	        // Pop a ) } ,
;  364	        else if (tok == tRParen || tok == tComma || tok == tRBrace) {
L_243:
	LD	A,(IX+-7)
	CP	A,17
	JR	Z,L_134
	LD	A,(IX+-7)
	CP	A,43
	JR	Z,L_134
	LD	A,(IX+-7)
	CP	A,9
	JR	Z,L_134
	JR	L_241
;  365	            uint8_t tempTok, index;
;  366	
;  367	            // Move until stack is empty or a function is encountered
;  368	            while (stackElements) {
L_135:
;  369	                stackPrev = &stackPtr[stackElements - 1];
	LD	IY,(IX+-10)
	LEA	BC,IY+-1
	LD	(IX+-102),BC
	LD	DE,(IX+-39)
	LD	HL,6
	CALL	__imulu
	ADD	HL,DE
	LD	(IX+-14),HL
;  370	                outputCurr = &outputPtr[outputElements];
	LD	HL,(IX+-3)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	LD	BC,(IX+-31)
	ADD	HL,BC
	LD	(IX+-6),HL
;  371	                if (stackPrev->type != TYPE_FUNCTION) {
	LD	IY,(IX+-14)
	LD	A,(IY+1)
	CP	A,127
	JR	Z,L_140
;  372	                    memcpy(outputCurr, stackPrev, sizeof(element_t));
	LD	BC,6
	PUSH	BC
	LD	BC,(IX+-14)
	PUSH	BC
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  373	                    stackElements--;
	LD	BC,(IX+-102)
	LD	(IX+-10),BC
;  374	                    outputElements++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  375	                } else {
;  376	                    break;
;  377	                }
;  378	            }
L_134:
	LD	HL,(IX+-10)
	CALL	__icmpzero
	JR	NZ,L_135
L_140:
;  379	
;  380	            // No matching left parenthesis
;  381	            if (!stackElements) {
	LD	HL,(IX+-10)
	CALL	__icmpzero
	JR	NZ,L_141
;  382	                if (expr.inFunction) {
	LD	A,(_expr+1)
	OR	A,A
	JR	Z,L_138
;  383	                    ice.tempToken = tok;
	LD	A,(IX+-7)
	LD	(_ice+69),A
;  384	                    
;  385	                    goto stopParsing;
	JR	L_136
;  386	                }
L_138:
;  387	                
;  388	                return E_EXTRA_RPAREN;
	LD	A,5
	JR	L_333
;  389	            }
L_141:
;  390	            
;  391	            stackPrev = &stackPtr[stackElements - 1];
	LD	IY,(IX+-10)
	LEA	BC,IY+-1
	LD	(IX+-105),BC
	LD	HL,6
	CALL	__imulu
	LD	BC,(IX+-39)
	ADD	HL,BC
	LD	(IX+-14),HL
;  392	            tempTok = stackPrev->operand.num;
	LD	IY,(IX+-14)
	LD	A,(IY+3)
	LD	(IX+-51),A
;  393	
;  394	            // Closing tag should match it's open tag
;  395	            if ((tok == tRBrace && (tempTok != token - 1)) || (tok == tRParen && tempTok != 0x0F && tempTok == tLBrace)) {
	LD	A,(IX+-7)
	CP	A,9
	JR	NZ,L_145
	LD	BC,(IX+6)
	DEC	BC
	LD	A,(IX+-51)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	JR	NZ,L_146
L_145:
	LD	A,(IX+-7)
	CP	A,17
	JR	NZ,L_147
	LD	A,(IX+-51)
	CP	A,15
	JR	Z,L_147
	LD	A,(IX+-51)
	CP	A,8
	JR	NZ,L_147
L_146:
;  396	                return E_SYNTAX;
	LD	A,6
	JR	L_333
;  397	            }
L_147:
;  398	
;  399	            index = GetIndexOfFunction(tempTok, stackPrev->operand.func.function2);
	LD	IY,(IX+-14)
	LD	C,(IY+5)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-51)
	PUSH	BC
	CALL	_GetIndexOfFunction
	POP	BC
	POP	BC
	LD	(IX+-74),A
;  400	
;  401	            // If it's a det, add an argument delimiter as well
;  402	            if (tok == tComma && index != 255 && implementedFunctions[index].pushBackwards) {
	LD	A,(IX+-7)
	CP	A,43
	JR	NZ,L_160
	LD	A,(IX+-74)
	CP	A,255
	JR	Z,L_160
	LD	A,(IX+-74)
	UEXT	HL
	LD	L,A
	LD	A,5
	CALL	__imul_b
	LD	BC,_implementedFunctions
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IY+4)
	OR	A,A
	JR	Z,L_160
;  403	                outputCurr->type = TYPE_ARG_DELIMITER;
	LD	IY,(IX+-6)
	LD	(IY+1),125
;  404	                outputElements++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  405	            }
L_160:
;  406	
;  407	            // If the right parenthesis belongs to a function, move the function as well
;  408	            if (tok != tComma) {
	LD	A,(IX+-7)
	CP	A,43
	JR	Z,L_159
;  409	                memcpy(outputCurr, stackPrev, sizeof(element_t));
	LD	BC,6
	PUSH	BC
	LD	BC,(IX+-14)
	PUSH	BC
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  410	                outputCurr->operand.func.amountOfArgs = *amountOfArgumentsStackPtr--;
	LD	BC,(IX+-17)
	LEA	IY,IX+-128
	LD	(IY+-30),BC
	LD	IY,(IX+-6)
	LEA	BC,IY+3
	LD	(IX+-108),BC
	LEA	IY,IX+-128
	LD	HL,(IY+-30)
	LD	A,(HL)
	LD	IY,(IX+-108)
	LD	(IY+1),A
	LD	IY,(IX+-17)
	LEA	BC,IY+-1
	LD	(IX+-17),BC
;  411	                if (stackPrev->operand.func.function == 0x0F) {
	LD	IY,(IX+-14)
	LD	A,(IY+3)
	CP	A,15
	JR	NZ,L_155
;  412	                    outputCurr->operand.func.function = tLBrace;
	LD	IY,(IX+-108)
	LD	(IY+0),8
;  413	                }
L_155:
;  414	                outputElements++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  415	
;  416	                // If you moved the function or not, it should always pop the last stack element
;  417	                stackElements--;
	LD	BC,(IX+-105)
	LD	(IX+-10),BC
;  418	            }
;  419	
;  420	            // Increment the amount of arguments for that function
;  421	            else {
	JR	L_161
L_159:
;  422	                (*amountOfArgumentsStackPtr)++;
	LD	HL,(IX+-17)
	LD	A,(HL)
	INC	A
	LD	HL,(IX+-17)
	LD	(HL),A
;  423	                canUseMask = 2;
	LD	(IX+-28),2
;  424	            }
L_161:
;  425	
;  426	            mask = TYPE_MASK_U24;
	LD	(IX+-11),2
;  427	        }
;  428	
;  429	        // getKey / getKey(
;  430	        else if (tok == tGetKey) {
	JR	L_227
L_241:
	LD	A,(IX+-7)
	CP	A,173
	JR	NZ,L_239
;  431	            mask = TYPE_MASK_U24;
	LD	(IX+-11),2
;  432	            if ((uint8_t)(token = _getc()) == tLParen) {
	CALL	_getNextToken
	LD	(IX+6),HL
	LD	A,(IX+6)
	CP	A,16
	JR	NZ,L_165
;  433	                *++amountOfArgumentsStackPtr = 1;
	LD	BC,(IX+-17)
	INC	BC
	LD	(IX+-17),BC
	LD	HL,BC
	LD	(HL),1
;  434	                stackCurr->type = TYPE_FUNCTION;
	LD	IY,(IX+-26)
	LD	(IY+1),127
;  435	                stackCurr->operand.func.function = tGetKey;
	LD	(IY+3),173
;  436	                stackElements++;
	LD	BC,(IX+-10)
	INC	BC
	LD	(IX+-10),BC
;  437	                canUseMask = 2;
	LD	(IX+-28),2
;  438	            } else {
	JR	L_227
L_165:
;  439	                outputCurr->type = TYPE_FUNCTION;
	LD	IY,(IX+-6)
	LD	(IY+1),127
;  440	                outputCurr->operand.func.function = tGetKey;
	LD	(IY+3),173
;  441	                outputElements++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  442	                
;  443	                continue;
	JR	L_262
;  444	            }
;  445	        }
;  446	
;  447	        // Parse a string of tokens
;  448	        else if (tok == tAPost) {
L_239:
	LD	A,(IX+-7)
	CP	A,174
	JR	NZ,L_237
;  449	            uint8_t *tempProgramPtr = ice.programPtr;
	LD	BC,(_ice+60)
	LD	(IX+-84),BC
;  450	            uint24_t length;
;  451	
;  452	            outputCurr->isString = true;
	LD	IY,(IX+-6)
	LD	(IY+0),1
;  453	            outputCurr->type = TYPE_STRING;
	LD	(IY+1),4
;  454	            outputElements++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  455	            mask = TYPE_MASK_U24;
	LD	(IX+-11),2
;  456	
;  457	            while ((token = _getc()) != EOF && (uint8_t)token != tEnter && (uint8_t)token != tColon && (uint8_t)token != tStore && (uint8_t)token != tAPost) {
	JR	L_172
L_173:
;  458	                OutputWriteByte(token);
	LD	C,(IX+6)
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  459	
;  460	                if (IsA2ByteTok(token)) {
	LD	C,(IX+6)
	LD	B,0
	PUSH	BC
	CALL	_IsA2ByteTok
	POP	BC
	OR	A,A
	JR	Z,L_172
;  461	                    OutputWriteByte(_getc());
	CALL	_getNextToken
	LD	C,L
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  462	                }
;  463	            }
L_172:
	CALL	_getNextToken
	LD	(IX+6),HL
	LD	BC,16777215
	OR	A,A
	SBC	HL,BC
	JR	Z,L_174
	LD	A,(IX+6)
	CP	A,63
	JR	Z,L_174
	LD	A,(IX+6)
	CP	A,62
	JR	Z,L_174
	LD	A,(IX+6)
	CP	A,4
	JR	Z,L_174
	LD	A,(IX+6)
	CP	A,174
	JR	NZ,L_173
L_174:
;  464	
;  465	            OutputWriteByte(0);
	LD	BC,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  466	
;  467	            length = ice.programPtr - tempProgramPtr;
	LD	BC,(IX+-84)
	LD	HL,(_ice+60)
	OR	A,A
	SBC	HL,BC
	LD	(IX+-126),HL
;  468	            ice.programDataPtr -= length;
	LD	HL,(_ice+66)
	LD	BC,(IX+-126)
	OR	A,A
	SBC	HL,BC
	LD	(_ice+66),HL
;  469	            memcpy(ice.programDataPtr, tempProgramPtr, length);
	LD	BC,(IX+-126)
	PUSH	BC
	LD	BC,(IX+-84)
	PUSH	BC
	LD	BC,(_ice+66)
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  470	            ice.programPtr = tempProgramPtr;
	LD	BC,(IX+-84)
	LD	(_ice+60),BC
;  471	
;  472	            outputCurr->operand.num = (uint24_t)ice.programDataPtr;
	LD	BC,(_ice+66)
	LD	IY,(IX+-6)
	LD	(IY+3),BC
;  473	
;  474	            if ((uint8_t)token == tStore || (uint8_t)token == tEnter || (uint8_t)token == tColon) {
	LD	A,(IX+6)
	CP	A,4
	JR	Z,L_262
	LD	A,(IX+6)
	CP	A,63
	JR	Z,L_262
	LD	A,(IX+6)
	CP	A,62
	JR	Z,L_262
	JR	L_227
;  475	                continue;
;  476	            }
;  477	        }
;  478	
;  479	        // Parse a string of characters
;  480	        else if (tok == tString) {
L_237:
	LD	A,(IX+-7)
	CP	A,42
	JR	NZ,L_235
;  481	            uint24_t length;
;  482	            uint8_t *tempDataPtr = ice.programPtr, *a;
	LD	BC,(_ice+60)
	LD	(IX+-54),BC
;  483	            uint8_t amountOfHexadecimals = 0;
	LD	(IX+-49),0
;  484	            bool needWarning = true;
	LD	(IX+-72),1
;  485	
;  486	            outputCurr->isString = true;
	LD	IY,(IX+-6)
	LD	(IY+0),1
;  487	            outputCurr->type = TYPE_STRING;
	LD	(IY+1),4
;  488	            outputElements++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  489	            mask = TYPE_MASK_U24;
	LD	(IX+-11),2
;  490	            stackPrev = &stackPtr[stackElements - 1];
	LD	IY,(IX+-10)
	LD	DE,(IX+-39)
;  491	
;  492	            token = grabString(&ice.programPtr, true);
	LD	HL,1
	PUSH	IY
	LEA	IY,IX+-128	; spill
	LD	(IY+-51),HL
	POP	IY
	LD	HL,_ice+60
	PUSH	IY
	LEA	IY,IX+-128	; spill
	LD	(IY+-54),HL
	POP	IY
	LEA	HL,IY+-1
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	ADD	HL,DE
	LD	(IX+-14),HL
	PUSH	IY
	LEA	IY,IX+-128	; unspill
	LD	HL,(IY+-51)
	POP	IY
	PUSH	HL
	PUSH	IY
	LEA	IY,IX+-128	; unspill
	LD	HL,(IY+-54)
	POP	IY
	PUSH	HL
	CALL	_grabString
	POP	BC
	POP	BC
	LD	(IX+6),HL
;  493	            if (stackElements && (uint8_t)stackPrev->operand.num == tVarOut && stackPrev->operand.func.function2 == tDefineSprite) {
	LD	HL,(IX+-10)
	CALL	__icmpzero
	JR	Z,L_190
	LD	IY,(IX+-14)
	LD	A,(IY+3)
	CP	A,98
	JR	NZ,L_190
	LD	IY,(IX+-14)
	LD	A,(IY+5)
	CP	A,10
	JR	NZ,L_190
;  494	                needWarning = false;
	LD	(IX+-72),0
;  495	            }
L_190:
;  496	            
;  497	            for (a = tempDataPtr; a < ice.programPtr; a++) {
	LD	BC,(IX+-54)
	LD	(IX+-64),BC
	JR	L_189
L_187:
;  498	                if (IsHexadecimal(*a) == 16) {
	LD	HL,(IX+-64)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_IsHexadecimal
	POP	BC
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,16
	SBC	HL,BC
	JR	Z,L_183
;  499	                    goto noSquishing;
;  500	                }
;  501	                amountOfHexadecimals++;
	INC	(IX+-49)
	LD	BC,(IX+-64)
	INC	BC
	LD	(IX+-64),BC
;  502	            }
L_189:
	LD	BC,(_ice+60)
	LD	HL,(IX+-64)
	OR	A,A
	SBC	HL,BC
	JR	C,L_187
;  503	            if (!(amountOfHexadecimals & 1)) {
	LD	A,(IX+-49)
	AND	A,1
	JR	NZ,L_183
;  504	                uint8_t *prevDataPtr = tempDataPtr;
	LD	BC,(IX+-54)
	LD	(IX+-46),BC
;  505	                uint8_t *prevDataPtr2 = tempDataPtr;
	LD	BC,(IX+-54)
	LD	(IX+-67),BC
;  506	
;  507	                while (prevDataPtr != ice.programPtr) {
	JR	L_194
L_195:
;  508	                    uint8_t tok1 = IsHexadecimal(*prevDataPtr++);
	LD	BC,(IX+-46)
	LEA	IY,IX+-128
	LD	(IY+-33),BC
	LD	BC,(IX+-46)
	INC	BC
	LD	(IX+-46),BC
	LD	HL,(IY+-33)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_IsHexadecimal
	POP	BC
	LD	(IX+-77),A
;  509	                    uint8_t tok2 = IsHexadecimal(*prevDataPtr++);
	LD	BC,(IX+-46)
	LEA	IY,IX+-128
	LD	(IY+-36),BC
	LD	BC,(IX+-46)
	INC	BC
	LD	(IX+-46),BC
	LD	HL,(IY+-36)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_IsHexadecimal
	POP	BC
	LD	(IX+-78),A
;  510	
;  511	                    *prevDataPtr2++ = (tok1 << 4) + tok2;
	LD	BC,(IX+-67)
	LEA	IY,IX+-128
	LD	(IY+-39),BC
	LD	A,(IX+-77)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	HL,(IY+-39)
	ADD	A,A
	ADD	A,(IX+-78)
	LD	(HL),A
	LD	BC,(IX+-67)
	INC	BC
	LD	(IX+-67),BC
;  512	                }
L_194:
	LD	BC,(IX+-46)
	LD	HL,(_ice+60)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_195
;  513	
;  514	                ice.programPtr = prevDataPtr2;
	LD	BC,(IX+-67)
	LD	(_ice+60),BC
;  515	
;  516	                if (needWarning) {
	LD	A,(IX+-72)
	OR	A,A
	JR	Z,L_183
;  517	                    displayError(W_SQUISHED);
	LD	BC,20
	PUSH	BC
	CALL	_displayError
	POP	BC
L_183:
;  518	                }
;  519	            }
;  520	
;  521	noSquishing:
;  522	            OutputWriteByte(0);
	LD	BC,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  523	            
;  524	            length = ice.programPtr - tempDataPtr;
	LD	BC,(IX+-54)
	LD	HL,(_ice+60)
	OR	A,A
	SBC	HL,BC
	LEA	IY,IX+-128
	LD	(IY+-1),HL
;  525	            ice.programDataPtr -= length;
	LD	HL,(_ice+66)
	LD	BC,(IY+-1)
	OR	A,A
	SBC	HL,BC
	LD	(_ice+66),HL
;  526	            memcpy(ice.programDataPtr, tempDataPtr, length);
	LD	BC,(IY+-1)
	PUSH	BC
	LD	BC,(IX+-54)
	PUSH	BC
	LD	BC,(_ice+66)
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  527	            ice.programPtr = tempDataPtr;
	LD	BC,(IX+-54)
	LD	(_ice+60),BC
;  528	            
;  529	            outputCurr->operand.num = (uint24_t)ice.programDataPtr;
	LD	BC,(_ice+66)
	LD	IY,(IX+-6)
	LD	(IY+3),BC
;  530	
;  531	            if ((uint8_t)token == tStore || (uint8_t)token == tEnter || (uint8_t)token == tColon) {
	LD	A,(IX+6)
	CP	A,4
	JR	Z,L_262
	LD	A,(IX+6)
	CP	A,63
	JR	Z,L_262
	LD	A,(IX+6)
	CP	A,62
	JR	Z,L_262
	JR	L_227
;  532	                continue;
;  533	            }
;  534	        }
;  535	
;  536	        // Parse an OS string
;  537	        else if (tok == tVarStrng) {
L_235:
	LD	A,(IX+-7)
	CP	A,170
	JR	NZ,L_233
;  538	            outputCurr->isString = true;
	LD	IY,(IX+-6)
	LD	(IY+0),1
;  539	            outputCurr->type = TYPE_NUMBER;
	LD	(IY+1),0
;  540	            outputCurr->operand.num = prescan.OSStrings[_getc()];
	CALL	_getNextToken
	LD	BC,HL
	LD	HL,3
	CALL	__imulu
	LD	BC,_prescan+409
	ADD	HL,BC
	LD	BC,(HL)
	LD	IY,(IX+-6)
	LD	(IY+3),BC
;  541	            outputElements++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  542	            mask = TYPE_MASK_U24;
	LD	(IX+-11),2
;  543	        }
;  544	
;  545	        // Parse a function
;  546	        else {
	JR	L_227
L_233:
;  547	            uint8_t index, tok2 = 0;
	LD	(IX+-32),0
;  548	
;  549	            if (IsA2ByteTok(tok)) {
	LD	C,(IX+-7)
	LD	B,0
	PUSH	BC
	CALL	_IsA2ByteTok
	POP	BC
	OR	A,A
	JR	Z,L_230
;  550	                tok2 = _getc();
	CALL	_getNextToken
	LD	(IX+-32),L
;  551	            }
L_230:
;  552	            
;  553	            if ((index = GetIndexOfFunction(tok, tok2)) != 255) {
	LD	C,(IX+-32)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-7)
	PUSH	BC
	CALL	_GetIndexOfFunction
	POP	BC
	POP	BC
	LD	(IX+-61),A
	CP	A,255
	JR	Z,L_231
;  554	                // LEFT and RIGHT should have a left paren associated with it
;  555	                if (tok == tExtTok && (tok2 == tLEFT || tok2 == tRIGHT)) {
	LD	A,(IX+-7)
	CP	A,239
	JR	NZ,L_226
	LD	A,(IX+-32)
	CP	A,146
	JR	Z,L_209
	LD	A,(IX+-32)
	CP	A,148
	JR	NZ,L_226
L_209:
;  556	                    if ((uint8_t)_getc() != tLParen) {
	CALL	_getNextToken
	LD	A,L
	CP	A,16
	JR	Z,L_226
;  557	                        return E_SYNTAX;
	LD	A,6
	JR	L_333
;  558	                    }
;  559	                }
L_226:
;  560	                
;  561	                if (implementedFunctions[index].amountOfArgs) {
	LD	A,(IX+-61)
	UEXT	HL
	LD	L,A
	LD	A,5
	CALL	__imul_b
	LD	BC,_implementedFunctions
	ADD	HL,BC
	LD	(IX+-111),HL
	LD	IY,(IX+-111)
	LD	A,(IY+2)
	OR	A,A
	JR	Z,L_225
;  562	                    // We always have at least 1 argument
;  563	                    *++amountOfArgumentsStackPtr = 1;
	LD	BC,(IX+-17)
	INC	BC
	LD	(IX+-17),BC
	LD	HL,BC
	LD	(HL),1
;  564	                    stackCurr->type = TYPE_FUNCTION;
	LD	IY,(IX+-26)
	LD	(IY+1),127
;  565	                    stackCurr->mask = mask;
	LD	A,(IX+-11)
	LD	(IY+2),A
;  566	                    stackCurr->operand.num = tok + (((tok == tLBrace && storeDepth) + tok2) << 16);
	LD	A,(IX+-7)
	CP	A,8
	JR	NZ,L_212
	LD	A,(IX+-36)
	OR	A,A
	JR	Z,L_212
	LD	BC,1
	LD	(IX+-123),BC
	JR	L_213
L_212:
	LD	BC,0
	LD	(IX+-123),BC
L_213:
	LD	A,(IX+-32)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-123)
	ADD	HL,BC
	LD	A,16
	CALL	__ishl_b
	LD	BC,HL
	LD	A,(IX+-7)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,(IX+-26)
	LD	(IY+3),HL
;  567	                    stackElements++;
	LD	BC,(IX+-10)
	INC	BC
	LD	(IX+-10),BC
;  568	                    mask = TYPE_MASK_U24;
	LD	(IX+-11),2
;  569	                    canUseMask = 2;
	LD	(IX+-28),2
;  570	
;  571	                    // Check if it's a function with pushed arguments
;  572	                    if (implementedFunctions[index].pushBackwards) {
	LD	IY,(IX+-111)
	LD	A,(IY+4)
	OR	A,A
	JR	Z,L_227
;  573	                        outputCurr->type = TYPE_C_START;
	LD	IY,(IX+-6)
	LD	(IY+1),124
;  574	                        outputElements++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  575	                        
;  576	                        tok2 = token = _getc();
	CALL	_getNextToken
	LD	(IX+6),HL
	LD	A,(IX+6)
	LD	(IX+-32),A
;  577	
;  578	                        if ((tok == tDet || tok == tSum) && (tok2 < t0 || tok2 > t9)) {
	LD	A,(IX+-7)
	CP	A,179
	JR	Z,L_219
	LD	A,(IX+-7)
	CP	A,182
	JR	NZ,L_221
L_219:
	LD	A,(IX+-32)
	CP	A,48
	JR	C,L_220
	LD	A,57
	CP	A,(IX+-32)
	JR	NC,L_221
L_220:
;  579	                            return E_SYNTAX;
	LD	A,6
	JR	L_333
;  580	                        }
L_221:
;  581	                        prevTokenWasCFunction = 2;
	LD	(IX+-40),2
;  582	                        tok = tok2;
	LD	A,(IX+-32)
	LD	(IX+-7),A
;  583	
;  584	                        goto fetchNoNewToken;
	JR	L_51
;  585	                    }
;  586	                } else {
L_225:
;  587	                    outputCurr->type = TYPE_FUNCTION;
	LD	IY,(IX+-6)
	LD	(IY+1),127
;  588	                    outputCurr->operand.num = (tok2 << 16) + tok;
	LD	A,(IX+-32)
	UEXT	HL
	LD	L,A
	LD	A,16
	CALL	__ishl_b
	LD	BC,HL
	LD	A,(IX+-7)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	(IY+3),HL
;  589	                    outputElements++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  590	                    mask = TYPE_MASK_U24;
	LD	(IX+-11),2
;  591	                }
;  592	                
;  593	                goto fetchNewToken;
	JR	L_227
;  594	            }
L_231:
;  595	
;  596	            // Oops, unknown token...
;  597	            return E_UNIMPLEMENTED;
	XOR	A,A
	JR	L_333
L_227:
;  598	        }
;  599	
;  600	        // Yay, fetch the next token, it's great, it's true, I like it
;  601	fetchNewToken:
;  602	        token = _getc();
	CALL	_getNextToken
	LD	(IX+6),HL
;  603	    }
L_262:
	LD	BC,16777215
	LD	HL,(IX+6)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_264
	LD	A,(IX+6)
	LD	(IX+-7),A
	CP	A,63
	JR	Z,L_264
	LD	A,(IX+-7)
	CP	A,62
	JR	NZ,L_51
L_264:
;  604	
;  605	    // If the expression quits normally, rather than an argument seperator
;  606	    ice.tempToken = tEnter;
	LD	A,63
	LD	(_ice+69),A
L_136:
;  607	
;  608	stopParsing:
;  609	    // Move entire stack to output
;  610	    stackToOutputReturn = 2;
	LD	(IX+-71),2
;  611	    goto stackToOutput;
	JR	L_328
;  612	stackToOutputReturn2:
L_265:
;  613	
;  614	    // Remove stupid things like 2+5, and not(1, max(2,3
;  615	    for (loopIndex = 1; loopIndex < outputElements; loopIndex++) {
	LD	BC,1
	LD	(IX+-23),BC
	JR	L_318
L_316:
;  616	        outputPrevPrev = &outputPtr[loopIndex - 2];
	LD	IY,(IX+-23)
	LEA	BC,IY+-2
	LD	(IX+-117),BC
	LD	HL,6
	CALL	__imulu
	LD	BC,(IX+-31)
	ADD	HL,BC
	LD	(IX+-60),HL
;  617	        outputPrev = &outputPtr[loopIndex - 1];
	LEA	HL,IY+-1
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	LD	BC,(IX+-31)
	ADD	HL,BC
	LD	(IX+-57),HL
;  618	        outputCurr = &outputPtr[loopIndex];
	LD	HL,(IX+-23)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	LD	BC,(IX+-31)
	ADD	HL,BC
	LD	(IX+-6),HL
;  619	        index = outputCurr->operand.func.amountOfArgs;
	LD	IY,(IX+-6)
	LEA	BC,IY+3
	LD	(IX+-114),BC
;  620	
;  621	        // Check if the types are number | number | operator (not both OS strings though)
;  622	        if (loopIndex > 1 && outputPrevPrev->type == TYPE_NUMBER && outputPrev->type == TYPE_NUMBER &&
	OR	A,A
	LD	A,(IY+4)
	LD	(IX+-27),A
	LD	BC,(IX+-23)
	LD	HL,1
	SBC	HL,BC
	JR	NC,L_314
	LD	IY,(IX+-60)
	LD	A,(IY+1)
	OR	A,A
	JR	NZ,L_314
	LD	IY,(IX+-57)
	LD	A,(IY+1)
	OR	A,A
	JR	NZ,L_314
;  623	               !(outputPrevPrev->isString && outputPrev->isString) && 
	LD	IY,(IX+-60)
	LD	A,(IY+0)
	OR	A,A
	JR	Z,L_271
	LD	IY,(IX+-57)
	LD	A,(IY+0)
	OR	A,A
	JR	NZ,L_314
L_271:
;  624	               outputCurr->type == TYPE_OPERATOR && outputCurr->operand.op != tStore) {
	LD	IY,(IX+-6)
	LD	A,(IY+1)
	CP	A,126
	JR	NZ,L_314
	LD	IY,(IX+-6)
	LEA	BC,IY+3
	LD	(IX+-114),BC
	LD	A,(IY+3)
	CP	A,4
	JR	Z,L_314
;  625	            // If yes, execute the operator, and store it in the first entry, and remove the other 2
;  626	            outputPrevPrev->operand.num = executeOperator(outputPrevPrev->operand.num, outputPrev->operand.num, outputCurr->operand.op);
	LD	IY,(IX+-6)
	LD	C,(IY+3)
	LD	B,0
	PUSH	BC
	LD	IY,(IX+-57)
	LD	BC,(IY+3)
	PUSH	BC
	LD	IY,(IX+-60)
	LD	BC,(IY+3)
	PUSH	BC
	CALL	_executeOperator
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+-60)
	LD	(IY+3),HL
;  627	            memcpy(outputPrev, &outputPtr[loopIndex + 1], (outputElements - 1) * sizeof(element_t));
	LD	IY,(IX+-3)
	LEA	HL,IY+-1
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	PUSH	HL
	LD	HL,(IX+-23)
	INC	HL
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	LD	BC,(IX+-31)
	ADD	HL,BC
	PUSH	HL
	LD	BC,(IX+-57)
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  628	            outputElements -= 2;
	LD	IY,(IX+-3)
	LEA	IY,IY+-2
	LD	(IX+-3),IY
;  629	            loopIndex -= 2;
	LD	BC,(IX+-117)
	LD	(IX+-23),BC
;  630	            continue;
	JR	L_317
;  631	        }
L_314:
;  632	
;  633	        // Check if the types are number | number | ... | function (specific function or pointer)
;  634	        if (loopIndex >= index && outputCurr->type == TYPE_FUNCTION) {
	LD	A,(IX+-27)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-23)
	OR	A,A
	SBC	HL,BC
	JR	C,L_317
	LD	IY,(IX+-6)
	LD	A,(IY+1)
	CP	A,127
	JR	NZ,L_317
;  635	            uint8_t a, index2, function = outputCurr->operand.func.function, function2 = outputCurr->operand.func.function2;
	LD	BC,(IX+-114)
	LEA	IY,IX+-128
	LD	(IY+-42),BC
	LD	IY,(IY+-42)
	LD	A,(IY+0)
	LD	(IX+-76),A
	LEA	IY,IX+-128
	LD	IY,(IY+-42)
	LD	A,(IY+2)
	LD	(IX+-50),A
;  636	            
;  637	            if ((index2 = GetIndexOfFunction(function, function2)) != 255 && implementedFunctions[index2].numbersArgs) {
	LD	C,(IX+-50)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-76)
	PUSH	BC
	CALL	_GetIndexOfFunction
	POP	BC
	POP	BC
	LD	(IX+-75),A
	CP	A,255
	JR	Z,L_317
	LD	A,(IX+-75)
	UEXT	HL
	LD	L,A
	LD	A,5
	CALL	__imul_b
	LD	BC,_implementedFunctions
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IY+3)
	OR	A,A
	JR	Z,L_317
;  638	                uint24_t outputPrevOperand = outputPrev->operand.num, outputPrevPrevOperand = outputPrevPrev->operand.num;
	LD	IY,(IX+-57)
	LD	BC,(IY+3)
	LD	(IX+-35),BC
	LD	IY,(IX+-60)
	LD	BC,(IY+3)
	LD	(IX+-43),BC
;  639	
;  640	                for (a = 1; a <= index; a++) {
	LD	(IX+-48),1
	JR	L_281
L_279:
;  641	                    if (outputPtr[loopIndex-a].type != TYPE_NUMBER) {
	LD	A,(IX+-48)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-23)
	OR	A,A
	SBC	HL,BC
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	LD	BC,(IX+-31)
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IY+1)
	OR	A,A
	JR	NZ,L_317
	INC	(IX+-48)
;  642	                        goto DontDeleteFunction;
;  643	                    }
;  644	                }
L_281:
	LD	A,(IX+-27)
	CP	A,(IX+-48)
	JR	NC,L_279
;  645	
;  646	                switch (function) {
	LD	A,(IX+-76)
	UEXT	HL
	LD	L,A
	CALL	__case8
L__128:
	DW	8
	DB	25
	DW24	L_292	

	DB	26
	DW24	L_287	

	DB	33
	DW24	L_297	

	DB	184
	DW24	L_282	

	DB	188
	DW24	L_298	

	DB	194
	DW24	L_307	

	DB	196
	DW24	L_308	

	DB	239
	DW24	L_299	

	DW24	L_309	

;  647	                    case tNot:
L_282:
;  648	                        temp = !outputPrevOperand;
	LD	HL,(IX+-35)
	CALL	__icmpzero
	JR	NZ,L_284
	LD	BC,1
	LEA	IY,IX+-128
	LD	(IY+-4),BC
	JR	L_285
L_284:
	LD	BC,0
	LEA	IY,IX+-128
	LD	(IY+-4),BC
L_285:
	LEA	IY,IX+-128
	LD	BC,(IY+-4)
	LD	(IX+-20),BC
;  649	                        break;
	JR	L_311
;  650	                    case tMin:
L_287:
;  651	                        temp = (outputPrevOperand < outputPrevPrevOperand) ? outputPrevOperand : outputPrevPrevOperand;
	LD	BC,(IX+-43)
	LD	HL,(IX+-35)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_290
	LD	BC,(IX+-35)
	LEA	IY,IX+-128
	LD	(IY+-7),BC
	JR	L_291
L_290:
	LD	BC,(IX+-43)
	LEA	IY,IX+-128
	LD	(IY+-7),BC
L_291:
	LEA	IY,IX+-128
	LD	BC,(IY+-7)
	LD	(IX+-20),BC
;  652	                        break;
	JR	L_311
;  653	                    case tMax:
L_292:
;  654	                        temp = (outputPrevOperand > outputPrevPrevOperand) ? outputPrevOperand : outputPrevPrevOperand;
	LD	BC,(IX+-35)
	LD	HL,(IX+-43)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_295
	LD	BC,(IX+-35)
	LD	(IX+-93),BC
	JR	L_296
L_295:
	LD	BC,(IX+-43)
	LD	(IX+-93),BC
L_296:
	LD	BC,(IX+-93)
	LD	(IX+-20),BC
;  655	                        break;
	JR	L_311
;  656	                    case tMean:
L_297:
;  657	                        // I can't simply add, and divide by 2, because then it *might* overflow in case that A + B > 0xFFFFFF
;  658	                        temp = ((long)outputPrevOperand + (long)outputPrevPrevOperand) / 2;
	XOR	A,A
	LD	E,A
	XOR	A,A
	LD	HL,(IX+-35)
	LD	BC,(IX+-43)
	CALL	__ladd
	LD	BC,2
	XOR	A,A
	CALL	__ldivs
	LD	(IX+-20),HL
;  659	                        break;
	JR	L_311
;  660	                    case tSqrt:
L_298:
;  661	                        temp = sqrt(outputPrevOperand);
	LD	BC,(IX+-35)
	XOR	A,A
	CALL	__ultof
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	CALL	_sqrt
	POP	BC
	POP	BC
	LD	A,E
	LD	BC,HL
	CALL	__ftol
	LD	(IX+-20),BC
;  662	                        break;
	JR	L_311
;  663	                    case tExtTok:
L_299:
;  664	                        if (function2 == tRemainder) {
	LD	A,(IX+-50)
	CP	A,50
	JR	NZ,L_305
;  665	                            temp = outputPrevOperand % outputPrevPrevOperand;
	LD	HL,(IX+-35)
	LD	BC,(IX+-43)
	CALL	__iremu
	LD	(IX+-20),HL
;  666	                        } else if (function2 == tLEFT) {
	JR	L_311
L_305:
	LD	A,(IX+-50)
	CP	A,146
	JR	NZ,L_303
;  667	                            temp = outputPrevPrevOperand << outputPrevOperand;
	LD	HL,(IX+-43)
	LD	BC,(IX+-35)
	CALL	__ishl
	LD	(IX+-20),HL
;  668	                        } else if (function2 == tRIGHT) {
	JR	L_311
L_303:
	LD	A,(IX+-50)
	CP	A,148
	JR	NZ,L_301
;  669	                            temp = outputPrevPrevOperand >> outputPrevOperand;
	LD	HL,(IX+-43)
	LD	BC,(IX+-35)
	CALL	__ishru
	LD	(IX+-20),HL
;  670	                        } else {
	JR	L_311
L_301:
;  671	                            return E_ICE_ERROR;
	LD	A,9
	JR	L_333
;  672	                        }
;  673	                        break;
;  674	                    case tSin:
L_307:
;  675	                        temp = 255*sin((double)outputPrevOperand * (2 * M_PI / 256));
	LD	BC,(IX+-35)
	XOR	A,A
	CALL	__ultof
	LD	HL,13176795
	LD	E,60
	CALL	__fmul
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	CALL	_sin
	POP	BC
	POP	BC
	LD	A,E
	LD	BC,HL
	LD	HL,8323072
	LD	E,67
	CALL	__fmul
	CALL	__ftol
	LD	(IX+-20),BC
;  676	                        break;
	JR	L_311
;  677	                    case tCos:
L_308:
;  678	                        temp = 255*cos((double)outputPrevOperand * (2 * M_PI / 256));
	LD	BC,(IX+-35)
	XOR	A,A
	CALL	__ultof
	LD	HL,13176795
	LD	E,60
	CALL	__fmul
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	CALL	_cos
	POP	BC
	POP	BC
	LD	A,E
	LD	BC,HL
	LD	HL,8323072
	LD	E,67
	CALL	__fmul
	CALL	__ftol
	LD	(IX+-20),BC
;  679	                        break;
	JR	L_311
;  680	                    default:
L_309:
;  681	                        return E_ICE_ERROR;
	LD	A,9
	JR	L_333
;  682	                }
L_311:
;  683	
;  684	                // And remove everything
;  685	                outputPtr[loopIndex - index].operand.num = temp;
	LD	A,(IX+-27)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-23)
	OR	A,A
	SBC	HL,BC
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	LD	BC,(IX+-31)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IX+-20)
	LD	(IY+3),BC
;  686	                memmove(&outputPtr[loopIndex - index + 1], &outputPtr[loopIndex + 1], (outputElements - 1) * sizeof(element_t));
	LD	IY,(IX+-3)
	LEA	HL,IY+-1
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	PUSH	HL
	LD	HL,(IX+-23)
	INC	HL
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	LD	BC,(IX+-31)
	ADD	HL,BC
	PUSH	HL
	LD	A,(IX+-27)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-23)
	OR	A,A
	SBC	HL,BC
	INC	HL
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	LD	BC,(IX+-31)
	ADD	HL,BC
	PUSH	HL
	CALL	_memmove
	POP	BC
	POP	BC
	POP	BC
;  687	                outputElements -= index;
	LD	A,(IX+-27)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	LD	(IX+-3),HL
;  688	                loopIndex -= index - 1;
	LD	A,(IX+-27)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-23)
	DEC	BC
	OR	A,A
	SBC	HL,BC
	LD	(IX+-23),HL
;  689	            }
;  690	        }
;  691	DontDeleteFunction:;
;  692	    }
L_317:
	LD	BC,(IX+-23)
	INC	BC
	LD	(IX+-23),BC
L_318:
	LD	BC,(IX+-3)
	LD	HL,(IX+-23)
	OR	A,A
	SBC	HL,BC
	JR	C,L_316
;  693	
;  694	    // Check if the expression is valid
;  695	    if (!outputElements) {
	LD	HL,(IX+-3)
	CALL	__icmpzero
	JR	NZ,L_321
;  696	        return E_SYNTAX;
	LD	A,6
	JR	L_333
;  697	    }
L_321:
;  698	
;  699	    return parsePostFixFromIndexToIndex(0, outputElements - 1);
	LD	IY,(IX+-3)
	LEA	BC,IY+-1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_parsePostFixFromIndexToIndex
	POP	BC
	POP	BC
	JR	L_333
;  700	
;  701	    // Duplicated function opt
;  702	stackToOutput:
;  703	    // Move entire stack to output
;  704	    while (stackElements) {
L_329:
;  705	        outputCurr = &outputPtr[outputElements++];
	LD	HL,6
	LD	BC,(IX+-3)
	CALL	__imulu
	LD	BC,(IX+-31)
	ADD	HL,BC
	LD	(IX+-6),HL
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  706	        stackPrev = &stackPtr[--stackElements];
	LD	IY,(IX+-10)
	LEA	BC,IY+-1
	LD	(IX+-10),BC
	LD	HL,BC
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	LD	BC,(IX+-39)
	ADD	HL,BC
	LD	(IX+-14),HL
;  707	
;  708	        temp = stackPrev->operand.num;
	LD	IY,(IX+-14)
	LD	BC,(IY+3)
	LD	(IX+-20),BC
;  709	        if ((uint8_t)temp == 0x0F) {
	LD	A,(IX+-20)
	CP	A,15
	JR	NZ,L_326
;  710	            // :D
;  711	            temp = (temp & 0xFF0000) + tLBrace;
	LD	HL,(IX+-20)
	LD	BC,16711680
	CALL	__iand
	LD	IY,HL
	LEA	IY,IY+8
	LD	(IX+-20),IY
;  712	        }
L_326:
;  713	
;  714	        // If it's a function, add the amount of arguments as well
;  715	        if (stackPrev->type == TYPE_FUNCTION) {
	LD	IY,(IX+-14)
	LD	A,(IY+1)
	LD	(IX+-73),A
	CP	A,127
	JR	NZ,L_327
;  716	            temp += (*amountOfArgumentsStackPtr--) << 8;
	LD	BC,(IX+-17)
	LEA	IY,IX+-128
	LD	(IY+-45),BC
	LD	HL,(IY+-45)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,8
	CALL	__ishl_b
	LD	BC,(IX+-20)
	ADD	HL,BC
	LD	(IX+-20),HL
	LD	IY,(IX+-17)
	LEA	IY,IY+-1
	LD	(IX+-17),IY
;  717	        }
L_327:
;  718	
;  719	        outputCurr->isString = stackPrev->isString;
	LD	IY,(IX+-14)
	LD	A,(IY+0)
	LD	IY,(IX+-6)
	LD	(IY+0),A
;  720	        outputCurr->type = stackPrev->type;
	LD	A,(IX+-73)
	LD	(IY+1),A
;  721	        outputCurr->mask = stackPrev->mask;
	LD	IY,(IX+-14)
	LD	A,(IY+2)
	LD	IY,(IX+-6)
	LD	(IY+2),A
;  722	        outputCurr->operand.num = temp;
	LD	BC,(IX+-20)
	LD	(IY+3),BC
;  723	    }
L_328:
	LD	HL,(IX+-10)
	CALL	__icmpzero
	JR	NZ,L_329
;  724	
;  725	    // Select correct return location
;  726	    if (stackToOutputReturn == 2) {
	LD	A,(IX+-71)
	CP	A,2
	JR	Z,L_265
	JR	L_117
;  727	        goto stackToOutputReturn2;
;  728	    }
;  729	
;  730	    goto stackToOutputReturn1;
;  731	}
L_333:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _parseExpression ***************************
;Name                         Addr/Register   Size   Type
;_parsePostFixFromIndexToIndex       IMPORT  -----   function
;_memmove                            IMPORT  -----   function
;_cos                                IMPORT  -----   function
;_sin                                IMPORT  -----   function
;_sqrt                               IMPORT  -----   function
;_executeOperator                    IMPORT  -----   function
;_displayError                       IMPORT  -----   function
;_grabString                         IMPORT  -----   function
;_IsA2ByteTok                        IMPORT  -----   function
;_OutputWriteByte                    IMPORT  -----   function
;_implementedFunctions               IMPORT    165   variable
;_GetIndexOfFunction                 IMPORT  -----   function
;_ice                                IMPORT  10958   variable
;_expr                               IMPORT     16   variable
;_memcpy                             IMPORT  -----   function
;_operatorPrecedence                 IMPORT  unknown variable
;_operatorPrecedence2                IMPORT  unknown variable
;_getIndexOfOperator                 IMPORT  -----   function
;_GetVariableOffset                  IMPORT  -----   function
;_prescan                            IMPORT   5833   variable
;_SeekMinus1                         IMPORT  -----   function
;_IsHexadecimal                      IMPORT  -----   function
;_getNextToken                       IMPORT  -----   function
;_memset                             IMPORT  -----   function
;_stack                              STATIC    300   variable
;_outputStack                        STATIC   2400   variable
;amountOfArgumentsStack              IX-155     20   variable
;temp288                             IX-135      3   variable
;temp286                             IX-132      3   variable
;length                              IX-129      3   variable
;length                              IX-126      3   variable
;temp214                             IX-123      3   variable
;temp92                              IX-120      3   variable
;G_12                                IX-117      3   variable
;G_13                                IX-114      3   variable
;G_9                                 IX-111      3   variable
;G_5                                 IX-108      3   variable
;G_6                                 IX-105      3   variable
;G_3                                 IX-102      3   variable
;G_1                                  IX-99      3   variable
;G_2                                  IX-96      3   variable
;temp293                              IX-93      3   variable
;output                               IX-90      3   variable
;output                               IX-87      3   variable
;tempProgramPtr                       IX-84      3   variable
;output                               IX-81      3   variable
;tok2                                 IX-78      1   variable
;tok1                                 IX-77      1   variable
;function                             IX-76      1   variable
;index2                               IX-75      1   variable
;index                                IX-74      1   variable
;G_14                                 IX-73      1   variable
;needWarning                          IX-72      1   variable
;stackToOutputReturn                  IX-71      1   variable
;output                               IX-70      3   variable
;prevDataPtr2                         IX-67      3   variable
;a                                    IX-64      3   variable
;index                                IX-61      1   variable
;outputPrevPrev                       IX-60      3   variable
;outputPrev                           IX-57      3   variable
;tempDataPtr                          IX-54      3   variable
;tempTok                              IX-51      1   variable
;function2                            IX-50      1   variable
;amountOfHexadecimals                 IX-49      1   variable
;a                                    IX-48      1   variable
;a                                    IX-47      1   variable
;prevDataPtr                          IX-46      3   variable
;outputPrevPrevOperand                IX-43      3   variable
;prevTokenWasCFunction                IX-40      1   variable
;stackPtr                             IX-39      3   variable
;storeDepth                           IX-36      1   variable
;outputPrevOperand                    IX-35      3   variable
;tok2                                 IX-32      1   variable
;outputPtr                            IX-31      3   variable
;canUseMask                           IX-28      1   variable
;index                                IX-27      1   variable
;stackCurr                            IX-26      3   variable
;loopIndex                            IX-23      3   variable
;temp                                 IX-20      3   variable
;amountOfArgumentsStackPtr            IX-17      3   variable
;stackPrev                            IX-14      3   variable
;mask                                 IX-11      1   variable
;stackElements                        IX-10      3   variable
;tok                                   IX-7      1   variable
;outputCurr                            IX-6      3   variable
;outputElements                        IX-3      3   variable
;token                                 IX+6      3   parameter


; Stack Frame Size: 191 (bytes)
;       Spill Code: 0 (instruction)


;  732	
;  733	uint8_t parsePostFixFromIndexToIndex(uint24_t startIndex, uint24_t endIndex) {
_parsePostFixFromIndexToIndex:
	LD	HL,-78
	CALL	__frameset
;  734	    element_t *outputCurr;
;  735	    element_t *outputPtr = (element_t*)outputStack;
	LD	BC,_outputStack
	LD	(IX+-11),BC
;  736	    uint8_t outputType, temp, AnsDepth = 0;
	LD	(IX+-8),0
;  737	    uint24_t outputOperand, loopIndex, tempIndex = 0, amountOfStackElements;
	LD	BC,0
	LD	(IX+-38),BC
;  738	
;  739	    // Set some variables
;  740	    outputCurr = &outputPtr[startIndex];
	LD	HL,(IX+6)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	LD	BC,_outputStack
	ADD	HL,BC
	LD	(IX+-3),HL
;  741	    outputType = outputCurr->type;
	LD	IY,(IX+-3)
	LD	A,(IY+1)
	LD	(IX+-12),A
;  742	    outputOperand = outputCurr->operand.num;
	LD	BC,(IY+3)
	LD	(IX+-26),BC
;  743	    ice.stackStart = (uint24_t*)(ice.stackDepth * STACK_SIZE + ice.stack);
	LD	A,(_ice+70)
	UEXT	HL
	LD	L,A
	LD	BC,1500
	CALL	__imuls
	LD	BC,_ice+3392
	ADD	HL,BC
	LD	(_ice+10892),HL
;  744	    setStackValues(ice.stackStart, ice.stackStart);
	LD	BC,(_ice+10892)
	PUSH	BC
	LD	BC,(_ice+10892)
	PUSH	BC
	CALL	_setStackValues
	POP	BC
	POP	BC
;  745	    reg.allowedToOptimize = true;
;  746	
;  747	    // Clean the expr struct
;  748	    memset(&expr, 0, sizeof expr);
	LD	BC,16
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_expr
	PUSH	BC
	LD	A,1
	LD	(_reg+9),A
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  749	
;  750	    // Get all the indexes of the expression
;  751	    temp = 0;
	LD	(IX+-4),0
;  752	    amountOfStackElements = 0;
	LD	BC,0
	LD	(IX+-15),BC
;  753	    
;  754	    for (loopIndex = startIndex; loopIndex <= endIndex; loopIndex++) {
	LD	BC,(IX+6)
	LD	(IX+-7),BC
	JR	L_348
L_346:
;  755	        uint8_t index;
;  756	        
;  757	        outputCurr = &outputPtr[loopIndex];
	LD	HL,(IX+-7)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	LD	BC,(IX+-11)
	ADD	HL,BC
	LD	(IX+-3),HL
;  758	        index = GetIndexOfFunction(outputCurr->operand.num, outputCurr->operand.func.function2);
	LD	IY,(IX+-3)
	LEA	BC,IY+3
	LD	(IX+-63),BC
	LD	IY,(IX+-63)
	LD	C,(IY+2)
	LD	B,0
	PUSH	BC
	LD	C,(IY+0)
	PUSH	BC
	CALL	_GetIndexOfFunction
	POP	BC
	POP	BC
	LD	(IX+-29),A
;  759	
;  760	        // If it's the start of a det( or sum(, increment the amount of nested det(/sum(
;  761	        if (outputCurr->type == TYPE_C_START) {
	LD	IY,(IX+-3)
	LD	A,(IY+1)
	LD	(IX+-28),A
	CP	A,124
	JR	NZ,L_342
;  762	            temp++;
	INC	(IX+-4)
;  763	        }
L_342:
;  764	        // If it's a det( or sum(, decrement the amount of nested dets
;  765	        if (outputCurr->type == TYPE_FUNCTION && index != 255 && implementedFunctions[index].pushBackwards) {
	LD	A,(IX+-28)
	CP	A,127
	JR	NZ,L_345
	LD	A,(IX+-29)
	CP	A,255
	JR	Z,L_345
	LD	A,(IX+-29)
	UEXT	HL
	LD	L,A
	LD	A,5
	CALL	__imul_b
	LD	BC,_implementedFunctions
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IY+4)
	OR	A,A
	JR	Z,L_345
;  766	            temp--;
	DEC	(IX+-4)
;  767	            amountOfStackElements++;
	LD	BC,(IX+-15)
	INC	BC
	LD	(IX+-15),BC
;  768	        }
L_345:
;  769	
;  770	        // If not in a nested det( or sum(, push the index
;  771	        if (!temp) {
	LD	A,(IX+-4)
	OR	A,A
	JR	NZ,L_347
;  772	            push(loopIndex);
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_push
	POP	BC
;  773	            amountOfStackElements++;
	LD	BC,(IX+-15)
	INC	BC
	LD	(IX+-15),BC
;  774	        }
;  775	    }
L_347:
	LD	BC,(IX+-7)
	INC	BC
	LD	(IX+-7),BC
L_348:
	LD	BC,(IX+-7)
	LD	HL,(IX+9)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_346
;  776	
;  777	    // Empty argument
;  778	    if (!amountOfStackElements) {
	LD	HL,(IX+-15)
	CALL	__icmpzero
	JR	NZ,L_361
;  779	        return E_SYNTAX;
	LD	A,6
	JR	L_424
;  780	    }
L_361:
;  781	
;  782	    // It's a single entry
;  783	    if (amountOfStackElements == 1) {
	LD	BC,1
	LD	HL,(IX+-15)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_420
;  784	        // Expression is a string
;  785	        if (outputCurr->isString) {
	LD	IY,(IX+-3)
	LD	A,(IY+0)
	OR	A,A
	JR	Z,L_358
;  786	            expr.outputIsString = true;
	LD	A,1
	LD	(_expr+4),A
;  787	            LD_HL_STRING(outputOperand, outputType);
	LD	C,(IX+-12)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-26)
	PUSH	BC
	CALL	_LD_HL_STRING
	POP	BC
	POP	BC
;  788	        }
;  789	        
;  790	        // Expression is only a single number
;  791	         else if (outputType == TYPE_NUMBER) {
	JR	L_359
L_358:
	LD	A,(IX+-12)
	OR	A,A
	JR	NZ,L_356
;  792	            // This boolean is set, because loops may be optimized when the condition is a number
;  793	            expr.outputIsNumber = true;
	LD	A,1
	LD	(_expr+2),A
;  794	            expr.outputNumber = outputOperand;
	LD	BC,(IX+-26)
	LD	(_expr+13),BC
;  795	            LD_HL_IMM(outputOperand);
	LD	BC,(IX+-26)
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_LoadRegValue
	POP	BC
	POP	BC
	JR	L_359
;  796	        }
;  797	
;  798	        // Expression is only a variable
;  799	        else if (outputType == TYPE_VARIABLE) {
L_356:
	LD	A,(IX+-12)
	CP	A,1
	JR	NZ,L_354
;  800	            expr.outputIsVariable = true;
;  801	            OutputWriteWord(0x27DD);
	LD	BC,10205
	PUSH	BC
	LD	A,1
	LD	(_expr+3),A
	CALL	_OutputWriteWord
	POP	BC
;  802	            OutputWriteByte(outputOperand);
	LD	C,(IX+-26)
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
;  803	            reg.HLIsNumber = false;
	XOR	A,A
	LD	(_reg),A
;  804	            reg.HLIsVariable = true;
	LD	A,1
	LD	(_reg+1),A
;  805	            reg.HLVariable = outputOperand;
	LD	A,(IX+-26)
	LD	(_reg+10),A
;  806	        }
;  807	
;  808	        // Expression is an empty function or operator, i.e. not(, +
;  809	        else {
	JR	L_359
L_354:
;  810	            return E_SYNTAX;
	LD	A,6
	JR	L_424
;  811	        }
L_359:
;  812	
;  813	        return VALID;
	LD	A,255
	JR	L_424
;  814	    }
;  815	
;  816	    // 3 or more entries, full expression
;  817	    do {
L_420:
;  818	        element_t *outputPrevPrevPrev;
;  819	
;  820	        outputCurr = &outputPtr[loopIndex = getNextIndex()];
	CALL	_getNextIndex
	LD	(IX+-7),HL
	LD	DE,(IX+-11)
;  821	        outputPrevPrevPrev = &outputPtr[getIndexOffset(-4)];
	LD	(IX+-66),HL	; spill
	LD	HL,16777212
	LD	(IX+-78),HL	; spill
	LD	HL,(IX+-66)	; unspill
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	ADD	HL,DE
	LD	(IX+-3),HL
	LD	HL,(IX+-78)	; unspill
	PUSH	HL
	CALL	_getIndexOffset
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	POP	BC
	LD	BC,(IX+-11)
	ADD	HL,BC
	LD	(IX+-54),HL
;  822	        outputType = outputCurr->type;
	LD	IY,(IX+-3)
	LD	A,(IY+1)
	LD	(IX+-12),A
;  823	        
;  824	        // Set some vars
;  825	        expr.outputReturnRegister = REGISTER_HL;
	XOR	A,A
	LD	(_expr+11),A
;  826	        expr.outputIsString = false;
	XOR	A,A
	LD	(_expr+4),A
;  827	
;  828	        if (outputType == TYPE_OPERATOR) {
	LD	A,(IX+-12)
	CP	A,126
	JR	NZ,L_416
;  829	            element_t *outputPrev, *outputPrevPrev, *outputNext, *outputNextNext;
;  830	            bool canOptimizeConcatenateStrings;
;  831	
;  832	            // Wait, invalid operator?!
;  833	            if (loopIndex < startIndex + 2) {
	LD	IY,(IX+6)
	LEA	BC,IY+2
	LD	HL,(IX+-7)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_365
;  834	                return E_SYNTAX;
	LD	A,6
	JR	L_424
;  835	            }
L_365:
;  836	
;  837	            if (AnsDepth > 3 && (uint8_t)outputCurr->operand.num != tStore) {
	LD	A,3
	CP	A,(IX+-8)
	JR	NC,L_366
	LD	IY,(IX+-3)
	LD	A,(IY+3)
	CP	A,4
	JR	Z,L_366
;  838	                // We need to push HL since it isn't used in the next operator/function
;  839	                outputPtr[tempIndex].type = TYPE_CHAIN_PUSH;
	LD	HL,(IX+-38)
	LD	DE,(IX+-11)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,HL
	LD	(IY+1),3
;  840	                PushHLDE();
	CALL	_PushHLDE
;  841	                expr.outputRegister = REGISTER_HL;
	XOR	A,A
	LD	(_expr+10),A
;  842	            }
L_366:
;  843	
;  844	            // Get the previous entries, -2 is the previous one, -3 is the one before etc
;  845	            outputPrev     = &outputPtr[getIndexOffset(-2)];
	LD	BC,16777214
	PUSH	BC
	CALL	_getIndexOffset
	POP	BC
	LD	DE,(IX+-11)
;  846	            outputPrevPrev = &outputPtr[getIndexOffset(-3)];
	LD	(IX+-66),HL	; spill
	LD	HL,16777213
	LD	(IX+-75),HL	; spill
	LD	HL,(IX+-66)	; unspill
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	ADD	HL,DE
	LD	(IX+-42),HL
	LD	HL,(IX+-75)	; unspill
	PUSH	HL
	CALL	_getIndexOffset
	POP	BC
	LD	DE,(IX+-11)
;  847	            outputNext     = &outputPtr[getIndexOffset(0)];
	LD	(IX+-66),HL	; spill
	OR	A,A
	SBC	HL,HL
	LD	(IX+-72),HL	; spill
	LD	HL,(IX+-66)	; unspill
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	ADD	HL,DE
	LD	(IX+-18),HL
	LD	HL,(IX+-72)	; unspill
	PUSH	HL
	CALL	_getIndexOffset
	POP	BC
	LD	DE,(IX+-11)
;  848	            outputNextNext = &outputPtr[getIndexOffset(1)];
	LD	(IX+-66),HL	; spill
	LD	HL,1
	LD	(IX+-69),HL	; spill
	LD	HL,(IX+-66)	; unspill
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	ADD	HL,DE
	LD	(IX+-45),HL
	LD	HL,(IX+-69)	; unspill
	PUSH	HL
	CALL	_getIndexOffset
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	POP	BC
	LD	BC,(IX+-11)
	ADD	HL,BC
	LD	(IX+-51),HL
;  849	            
;  850	            // Check if we can optimize StrX + "..." -> StrX
;  851	            canOptimizeConcatenateStrings = (
;  852	                (uint8_t)(outputCurr->operand.num) == tAdd &&
	LD	IY,(IX+-3)
	LD	A,(IY+3)
	CP	A,112
	JR	NZ,L_375
;  853	                outputPrevPrev->isString && outputPrevPrev->type == TYPE_NUMBER &&
	LD	IY,(IX+-18)
	LD	A,(IY+0)
	OR	A,A
	JR	Z,L_375
	LD	IY,(IX+-18)
	LD	A,(IY+1)
	OR	A,A
	JR	NZ,L_375
;  854	                outputNext->isString && outputNext->type == TYPE_NUMBER &&
	LD	IY,(IX+-45)
	LD	A,(IY+0)
	OR	A,A
	JR	Z,L_375
	LD	IY,(IX+-45)
	LD	A,(IY+1)
	OR	A,A
	JR	NZ,L_375
;  855	                outputNext->operand.num == outputPrevPrev->operand.num &&
	LD	IY,(IX+-18)
	LD	BC,(IY+3)
	LD	IY,(IX+-45)
	LD	HL,(IY+3)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_375
;  856	                outputNextNext->type == TYPE_OPERATOR &&
	LD	IY,(IX+-51)
	LD	A,(IY+1)
	CP	A,126
	JR	NZ,L_375
;  857	                (uint8_t)(outputNextNext->operand.num) == tStore
;  858	            );
	LD	IY,(IX+-51)
	LD	A,(IY+3)
	CP	A,4
	JR	NZ,L_375
	LD	BC,1
	LD	(IX+-57),BC
	JR	L_376
L_375:
	LD	BC,0
	LD	(IX+-57),BC
L_376:
	LD	A,(IX+-57)
	LD	(IX+-27),A
;  859	
;  860	            // Parse the operator with the 2 latest operands of the stack!
;  861	            if ((temp = parseOperator(outputPrevPrevPrev, outputPrevPrev, outputPrev, outputCurr, canOptimizeConcatenateStrings)) != VALID) {
	LD	C,(IX+-27)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	LD	BC,(IX+-42)
	PUSH	BC
	LD	BC,(IX+-18)
	PUSH	BC
	LD	BC,(IX+-54)
	PUSH	BC
	CALL	_parseOperator
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-4),A
	CP	A,255
	JR	Z,L_379
;  862	                return temp;
	LD	A,(IX+-4)
	JR	L_424
;  863	            }
L_379:
;  864	
;  865	            // Remove the index of the first and the second argument, the index of the operator will be the chain
;  866	            removeIndexFromStack(getCurrentIndex() - 2);
	CALL	_getCurrentIndex
	DEC	HL
	DEC	HL
	PUSH	HL
	CALL	_removeIndexFromStack
	POP	BC
;  867	            removeIndexFromStack(getCurrentIndex() - 2);
	CALL	_getCurrentIndex
	DEC	HL
	DEC	HL
	PUSH	HL
	CALL	_removeIndexFromStack
	POP	BC
;  868	            AnsDepth = 0;
	LD	(IX+-8),0
;  869	
;  870	            // Eventually remove the ->StrX too
;  871	            if (canOptimizeConcatenateStrings) {
	LD	A,(IX+-27)
	OR	A,A
	JR	Z,L_390
;  872	                loopIndex = getIndexOffset(1);
	LD	BC,1
	PUSH	BC
	CALL	_getIndexOffset
	POP	BC
	LD	(IX+-7),HL
;  873	                removeIndexFromStack(getCurrentIndex());
	CALL	_getCurrentIndex
	PUSH	HL
	CALL	_removeIndexFromStack
	POP	BC
;  874	                removeIndexFromStack(getCurrentIndex() + 1);
	CALL	_getCurrentIndex
	INC	HL
	PUSH	HL
	CALL	_removeIndexFromStack
	POP	BC
;  875	
;  876	                outputCurr->isString = true;
	LD	IY,(IX+-3)
	LD	(IY+0),1
;  877	                outputCurr->type = TYPE_NUMBER;
	LD	(IY+1),0
;  878	                outputCurr->operand.num = outputPrevPrev->operand.num;
	LD	IY,(IX+-18)
	LD	BC,(IY+3)
	LD	IY,(IX+-3)
	LD	(IY+3),BC
;  879	                expr.outputIsString = true;
	LD	A,1
	LD	(_expr+4),A
;  880	            } else {
	JR	L_419
L_390:
;  881	                // Check if it was a command with 2 strings, then the output is a string, not Ans
;  882	                if ((uint8_t)outputCurr->operand.num == tAdd && outputPrevPrev->isString && outputPrev->isString) {
	LD	IY,(IX+-3)
	LD	A,(IY+3)
	CP	A,112
	JR	NZ,L_387
	LD	IY,(IX+-18)
	LD	A,(IY+0)
	OR	A,A
	JR	Z,L_387
	LD	IY,(IX+-42)
	LD	A,(IY+0)
	OR	A,A
	JR	Z,L_387
;  883	                    outputCurr->isString = true;
	LD	IY,(IX+-3)
	LD	(IY+0),1
;  884	                    outputCurr->type = TYPE_STRING;
	LD	(IY+1),4
;  885	                    if (outputPrevPrev->operand.num == prescan.tempStrings[TempString2] || outputPrev->operand.num == prescan.tempStrings[TempString1]) {
	LD	BC,_prescan+472
	LD	(IX+-22),BC
	LD	IY,(IX+-22)
	LEA	BC,IY+3
	LD	(IX+-60),BC
	LD	HL,BC
	LD	BC,(HL)
	LD	IY,(IX+-18)
	LD	HL,(IY+3)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_383
	LD	HL,(IX+-22)
	LD	BC,(HL)
	LD	IY,(IX+-42)
	LD	HL,(IY+3)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_384
L_383:
;  886	                        outputCurr->operand.num = prescan.tempStrings[TempString2];
	LD	HL,(IX+-60)
	LD	BC,(HL)
	LD	IY,(IX+-3)
	LD	(IY+3),BC
;  887	                    } else {
	JR	L_385
L_384:
;  888	                        outputCurr->operand.num = prescan.tempStrings[TempString1];
	LD	HL,(IX+-22)
	LD	BC,(HL)
	LD	IY,(IX+-3)
	LD	(IY+3),BC
;  889	                    }
L_385:
;  890	                    expr.outputIsString = true;
	LD	A,1
	LD	(_expr+4),A
;  891	                } else {
	JR	L_388
L_387:
;  892	                    AnsDepth = 1;
	LD	(IX+-8),1
;  893	                    outputCurr->type = TYPE_CHAIN_ANS;
	LD	IY,(IX+-3)
	LD	(IY+1),2
;  894	                }
L_388:
;  895	                tempIndex = loopIndex;
	LD	BC,(IX+-7)
	LD	(IX+-38),BC
;  896	            }
;  897	        }
;  898	
;  899	        else if (outputType == TYPE_FUNCTION) {
	JR	L_419
L_416:
	LD	A,(IX+-12)
	CP	A,127
	JR	NZ,L_419
;  900	            // Use this to cleanup the function after parsing
;  901	            uint8_t amountOfArguments = outputCurr->operand.func.amountOfArgs;
	LD	IY,(IX+-3)
	LD	A,(IY+4)
	LD	(IX+-23),A
;  902	            uint8_t function2 = outputCurr->operand.func.function2;
	LD	A,(IY+5)
	LD	(IX+-39),A
;  903	            
;  904	            // Only execute when it's not a pointer directly after a ->
;  905	            if (outputCurr->operand.num != 0x010108) {
	LD	HL,(IY+3)
	LD	BC,65800
	OR	A,A
	SBC	HL,BC
	JR	Z,L_419
;  906	                uint8_t index = GetIndexOfFunction(outputCurr->operand.num, function2);
	LD	C,(IX+-39)
	LD	B,0
	PUSH	BC
	LD	IY,(IX+-3)
	LD	C,(IY+3)
	PUSH	BC
	CALL	_GetIndexOfFunction
	POP	BC
	POP	BC
	LD	(IX+-19),A
;  907	                
;  908	                // Check if we need to push Ans
;  909	                if (AnsDepth > 1 + amountOfArguments || (AnsDepth && implementedFunctions[index].pushBackwards)) {
	LD	A,(IX+-23)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	INC	BC
	LD	A,(IX+-8)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	JP	M,L_393
	LD	A,(IX+-8)
	OR	A,A
	JR	Z,L_396
	LD	A,(IX+-19)
	UEXT	HL
	LD	L,A
	LD	A,5
	CALL	__imul_b
	LD	BC,_implementedFunctions
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IY+4)
	OR	A,A
	JR	Z,L_396
L_393:
;  910	                    // We need to push HL since it isn't used in the next operator/function
;  911	                    outputPtr[tempIndex].type = TYPE_CHAIN_PUSH;
	LD	HL,(IX+-38)
	LD	DE,(IX+-11)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,HL
	LD	(IY+1),3
;  912	                    PushHLDE();
	CALL	_PushHLDE
;  913	                    expr.outputRegister = REGISTER_HL;
	XOR	A,A
	LD	(_expr+10),A
;  914	                }
L_396:
;  915	                
;  916	                if (amountOfArguments != implementedFunctions[index].amountOfArgs && implementedFunctions[index].amountOfArgs != 255) {
	LD	A,(IX+-19)
	UEXT	HL
	LD	L,A
	LD	A,5
	CALL	__imul_b
	LD	BC,_implementedFunctions
	ADD	HL,BC
	LD	(IX+-32),HL
	LD	(IX+-48),HL
	LD	IY,(IX+-32)
	LD	A,(IY+2)
	CP	A,(IX+-23)
	JR	Z,L_398
	LD	BC,(IX+-32)
	LD	(IX+-48),BC
	LD	IY,(IX+-32)
	LD	A,(IY+2)
	CP	A,255
	JR	Z,L_398
;  917	                    return E_ARGUMENTS;
	LD	A,10
	JR	L_424
;  918	                }
L_398:
;  919	
;  920	                if ((temp = parseFunction(loopIndex)) != VALID) {
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_parseFunction
	POP	BC
	LD	(IX+-4),A
	CP	A,255
	JR	Z,L_405
;  921	                    return temp;
	LD	A,(IX+-4)
	JR	L_424
;  922	                }
L_405:
;  923	
;  924	                // Cleanup, if it's not a det(
;  925	                if (index == 255 || !implementedFunctions[index].pushBackwards) {
	LD	A,(IX+-19)
	CP	A,255
	JR	Z,L_404
	LD	IY,(IX+-48)
	LD	A,(IY+4)
	OR	A,A
	JR	NZ,L_412
L_404:
;  926	                    for (temp = 0; temp < amountOfArguments; temp++) {
	LD	(IX+-4),0
	JR	L_403
L_401:
;  927	                        removeIndexFromStack(getCurrentIndex() - 2);
	CALL	_getCurrentIndex
	DEC	HL
	DEC	HL
	PUSH	HL
	CALL	_removeIndexFromStack
	POP	BC
	INC	(IX+-4)
;  928	                    }
L_403:
	LD	A,(IX+-4)
	CP	A,(IX+-23)
	JR	C,L_401
;  929	                }
L_412:
;  930	
;  931	                // I don't care that this will be ignored when it's a pointer, because I know there is a -> directly after
;  932	                // If it's a sub(, the output should be a string, not Ans
;  933	                if ((uint8_t)outputCurr->operand.num == t2ByteTok && function2 == tSubStrng) {
	LD	IY,(IX+-3)
	LD	A,(IY+3)
	CP	A,187
	JR	NZ,L_411
	LD	A,(IX+-39)
	CP	A,12
	JR	NZ,L_411
;  934	                    outputCurr->isString = true;
	LD	IY,(IX+-3)
	LD	(IY+0),1
;  935	                    outputCurr->type = TYPE_STRING;
	LD	(IY+1),4
;  936	                    if (outputPrevPrevPrev->operand.num == prescan.tempStrings[TempString1]) {
	LD	BC,_prescan+472
	LD	(IX+-35),BC
	LD	HL,BC
	LD	BC,(HL)
	LD	IY,(IX+-54)
	LD	HL,(IY+3)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_408
;  937	                        outputCurr->operand.num = prescan.tempStrings[TempString2];
	LD	IY,(IX+-35)
	LEA	HL,IY+3
	LD	BC,(HL)
	LD	IY,(IX+-3)
	LD	(IY+3),BC
;  938	                    } else {
	JR	L_409
L_408:
;  939	                        outputCurr->operand.num = prescan.tempStrings[TempString1];
	LD	HL,(IX+-35)
	LD	BC,(HL)
	LD	IY,(IX+-3)
	LD	(IY+3),BC
;  940	                    }
L_409:
;  941	                    expr.outputIsString = true;
	LD	A,1
	LD	(_expr+4),A
;  942	                    AnsDepth = 0;
	LD	(IX+-8),0
;  943	                }
;  944	
;  945	                // Check chain push/ans
;  946	                else {
	JR	L_419
L_411:
;  947	                    AnsDepth = 1;
	LD	(IX+-8),1
;  948	                    tempIndex = loopIndex;
	LD	BC,(IX+-7)
	LD	(IX+-38),BC
;  949	                    outputCurr->type = TYPE_CHAIN_ANS;
	LD	IY,(IX+-3)
	LD	(IY+1),2
;  950	                }
;  951	            }
;  952	        }
L_419:
;  953	
;  954	        if (AnsDepth) {
	LD	A,(IX+-8)
	OR	A,A
	JR	Z,L_421
;  955	            AnsDepth++;
	INC	(IX+-8)
;  956	        }
;  957	    } while (loopIndex != endIndex);
L_421:
	LD	BC,(IX+9)
	LD	HL,(IX+-7)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_420
;  958	
;  959	    return VALID;
	LD	A,255
;  960	}
L_424:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _parsePostFixFromIndexToIndex ***************************
;Name                         Addr/Register   Size   Type
;_parseFunction                      IMPORT  -----   function
;_prescan                            IMPORT   5833   variable
;_getCurrentIndex                    IMPORT  -----   function
;_removeIndexFromStack               IMPORT  -----   function
;_parseOperator                      IMPORT  -----   function
;_PushHLDE                           IMPORT  -----   function
;_getIndexOffset                     IMPORT  -----   function
;_getNextIndex                       IMPORT  -----   function
;_OutputWriteByte                    IMPORT  -----   function
;_OutputWriteWord                    IMPORT  -----   function
;_LoadRegValue                       IMPORT  -----   function
;_LD_HL_STRING                       IMPORT  -----   function
;_push                               IMPORT  -----   function
;_implementedFunctions               IMPORT    165   variable
;_GetIndexOfFunction                 IMPORT  -----   function
;_expr                               IMPORT     16   variable
;_memset                             IMPORT  -----   function
;_reg                                IMPORT     28   variable
;_setStackValues                     IMPORT  -----   function
;_ice                                IMPORT  10958   variable
;_outputStack                        STATIC   2400   variable
;G_18                                 IX-60      3   variable
;temp377                              IX-57      3   variable
;outputPrevPrevPrev                   IX-54      3   variable
;outputNextNext                       IX-51      3   variable
;G_23                                 IX-48      3   variable
;outputNext                           IX-45      3   variable
;outputPrev                           IX-42      3   variable
;function2                            IX-39      1   variable
;tempIndex                            IX-38      3   variable
;G_24                                 IX-35      3   variable
;G_21                                 IX-32      3   variable
;index                                IX-29      1   variable
;G_15                                 IX-28      1   variable
;canOptimizeConcatenateStrings        IX-27      1   variable
;outputOperand                        IX-26      3   variable
;amountOfArguments                    IX-23      1   variable
;G_16                                 IX-22      3   variable
;index                                IX-19      1   variable
;outputPrevPrev                       IX-18      3   variable
;amountOfStackElements                IX-15      3   variable
;outputType                           IX-12      1   variable
;outputPtr                            IX-11      3   variable
;AnsDepth                              IX-8      1   variable
;loopIndex                             IX-7      3   variable
;temp                                  IX-4      1   variable
;outputCurr                            IX-3      3   variable
;endIndex                              IX+9      3   parameter
;startIndex                            IX+6      3   parameter


; Stack Frame Size: 90 (bytes)
;       Spill Code: 0 (instruction)


;  961	
;  962	static uint8_t functionI(int token) {
_functionI:
	CALL	__frameset0
;  963	    skipLine();
	CALL	_skipLine
;  964	
;  965	    return VALID;
	LD	A,255
;  966	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionI ***************************
;Name                         Addr/Register   Size   Type
;_skipLine                           IMPORT  -----   function
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  967	
;  968	static uint8_t functionIf(int token) {
_functionIf:
	LD	HL,-21
	CALL	__frameset
;  969	    uint8_t *IfElseAddr = NULL;
;  970	    uint8_t tempGotoElements = ice.curGoto;
	LD	A,(_ice+10898)
	LD	(IX+-2),A
;  971	    uint8_t tempLblElements = ice.curLbl;
	LD	A,(_ice+10895)
	LD	(IX+-3),A
;  972	    
;  973	    if ((token = _getc()) != EOF && token != tEnter && token != tColon) {
	CALL	_getNextToken
	LD	(IX+6),HL
	LD	BC,16777215
	OR	A,A
	SBC	HL,BC
	JR	Z,L_465
	LD	BC,63
	LD	HL,(IX+6)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_465
	LD	BC,62
	LD	HL,(IX+6)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_465
;  974	        uint8_t *IfStartAddr, res;
;  975	        uint24_t tempDataOffsetElements;
;  976	
;  977	        // Parse the argument
;  978	        if ((res = parseExpression(token)) != VALID) {
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_parseExpression
	POP	BC
	LD	(IX+-1),A
	CP	A,255
	JR	Z,L_430
;  979	            return res;
	LD	A,(IX+-1)
	JR	L_466
;  980	        }
L_430:
;  981	
;  982	        if (expr.outputIsString) {
	LD	A,(_expr+4)
	OR	A,A
	JR	Z,L_431
;  983	            return E_SYNTAX;
	LD	A,6
	JR	L_466
;  984	        }
L_431:
;  985	
;  986	        //Check if we can optimize stuff :D
;  987	        optimizeZeroCarryFlagOutput();
	CALL	_optimizeZeroCarryFlagOutput
;  988	
;  989	        // Backup stuff
;  990	        IfStartAddr = ice.programPtr;
	LD	BC,(_ice+60)
	LD	(IX+-18),BC
;  991	        tempDataOffsetElements = ice.dataOffsetElements;
	LD	BC,(_ice+3077)
	LD	(IX+-15),BC
;  992	
;  993	        if (expr.AnsSetCarryFlag || expr.AnsSetCarryFlagReversed) {
	LD	A,(_expr+7)
	OR	A,A
	JR	NZ,L_445
	LD	A,(_expr+8)
	OR	A,A
	JR	Z,L_446
L_445:
;  994	            if (expr.AnsSetCarryFlagReversed) {
	LD	A,(_expr+8)
	OR	A,A
	JR	Z,L_438
;  995	                JP_NC(0);
	LD	BC,210
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	BC,0
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
	JR	L_447
;  996	            } else {
L_438:
;  997	                JP_C(0);
	LD	BC,218
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	BC,0
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
	JR	L_447
;  998	            }
;  999	        } else {
L_446:
; 1000	            if (expr.AnsSetZeroFlagReversed) {
	LD	A,(_expr+6)
	OR	A,A
	JR	Z,L_444
; 1001	                JP_NZ(0);
	LD	BC,194
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	BC,0
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
	JR	L_447
; 1002	            } else {
L_444:
; 1003	                JP_Z(0);
	LD	BC,202
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	BC,0
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
; 1004	            }
; 1005	        }
L_447:
; 1006	        res = parseProgramUntilEnd();
	CALL	_parseProgramUntilEnd
	LD	(IX+-1),A
; 1007	
; 1008	        // Check if we quit the program with an 'Else'
; 1009	        if (res == E_ELSE) {
	CP	A,3
	JR	NZ,L_462
; 1010	            bool shortElseCode;
; 1011	            uint8_t tempGotoElements2 = ice.curGoto;
	LD	A,(_ice+10898)
	LD	(IX+-6),A
; 1012	            uint8_t tempLblElements2 = ice.curLbl;
	LD	A,(_ice+10895)
	LD	(IX+-4),A
; 1013	            uint24_t tempDataOffsetElements2;
; 1014	
; 1015	            // Backup stuff
; 1016	            ResetAllRegs();
	CALL	_ResetAllRegs
; 1017	            IfElseAddr = ice.programPtr;
	LD	BC,(_ice+60)
	LD	(IX+-12),BC
; 1018	            tempDataOffsetElements2 = ice.dataOffsetElements;
	LD	BC,(_ice+3077)
	LD	(IX+-21),BC
; 1019	
; 1020	            JP(0);
	LD	BC,195
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	BC,0
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
; 1021	            if ((res = parseProgramUntilEnd()) != E_END && res != VALID) {
	CALL	_parseProgramUntilEnd
	LD	(IX+-1),A
	CP	A,4
	JR	Z,L_453
	LD	A,(IX+-1)
	CP	A,255
	JR	Z,L_453
; 1022	                return res;
	LD	A,(IX+-1)
	JR	L_466
; 1023	            }
L_453:
; 1024	
; 1025	            shortElseCode = JumpForward(IfElseAddr, ice.programPtr, tempDataOffsetElements2, tempGotoElements2, tempLblElements2);
	LD	C,(IX+-4)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-6)
	PUSH	BC
	LD	BC,(IX+-21)
	PUSH	BC
	LD	BC,(_ice+60)
	PUSH	BC
	LD	BC,(IX+-12)
	PUSH	BC
	CALL	_JumpForward
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-5),A
; 1026	            JumpForward(IfStartAddr, IfElseAddr + (shortElseCode ? 2 : 4), tempDataOffsetElements, tempGotoElements, tempLblElements);
	OR	A,A
	JR	Z,L_456
	LD	BC,2
	LD	(IX+-9),BC
	JR	L_457
L_456:
	LD	BC,4
	LD	(IX+-9),BC
L_457:
	LD	C,(IX+-3)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-2)
	PUSH	BC
	LD	BC,(IX+-15)
	PUSH	BC
	LD	BC,(IX+-9)
	LD	HL,(IX+-12)
	ADD	HL,BC
	PUSH	HL
	LD	BC,(IX+-18)
	PUSH	BC
	CALL	_JumpForward
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
; 1027	        }
; 1028	
; 1029	        // Check if we quit the program with an 'End' or at the end of the input program
; 1030	        else if (res == E_END || res == VALID) {
	JR	L_463
L_462:
	LD	A,(IX+-1)
	CP	A,4
	JR	Z,L_459
	LD	A,(IX+-1)
	CP	A,255
	JR	NZ,L_460
L_459:
; 1031	            JumpForward(IfStartAddr, ice.programPtr, tempDataOffsetElements, tempGotoElements, tempLblElements);
	LD	C,(IX+-3)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-2)
	PUSH	BC
	LD	BC,(IX+-15)
	PUSH	BC
	LD	BC,(_ice+60)
	PUSH	BC
	LD	BC,(IX+-18)
	PUSH	BC
	CALL	_JumpForward
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
; 1032	        } else {
	JR	L_463
L_460:
; 1033	            return res;
	LD	A,(IX+-1)
	JR	L_466
; 1034	        }
L_463:
; 1035	
; 1036	        ResetAllRegs();
	CALL	_ResetAllRegs
; 1037	
; 1038	        return VALID;
	LD	A,255
	JR	L_466
; 1039	    } else {
L_465:
; 1040	        return E_NO_CONDITION;
	LD	A,2
; 1041	    }
; 1042	}
L_466:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionIf ***************************
;Name                         Addr/Register   Size   Type
;_JumpForward                        IMPORT  -----   function
;_ResetAllRegs                       IMPORT  -----   function
;_parseProgramUntilEnd               IMPORT  -----   function
;_OutputWriteLong                    IMPORT  -----   function
;_OutputWriteByte                    IMPORT  -----   function
;_optimizeZeroCarryFlagOutput        IMPORT  -----   function
;_expr                               IMPORT     16   variable
;_getNextToken                       IMPORT  -----   function
;_ice                                IMPORT  10958   variable
;tempDataOffsetElements2              IX-21      3   variable
;IfStartAddr                          IX-18      3   variable
;tempDataOffsetElements               IX-15      3   variable
;IfElseAddr                           IX-12      3   variable
;temp454                               IX-9      3   variable
;tempGotoElements2                     IX-6      1   variable
;shortElseCode                         IX-5      1   variable
;tempLblElements2                      IX-4      1   variable
;tempLblElements                       IX-3      1   variable
;tempGotoElements                      IX-2      1   variable
;res                                   IX-1      1   variable
;token                                 IX+6      3   parameter


; Stack Frame Size: 30 (bytes)
;       Spill Code: 0 (instruction)


; 1043	
; 1044	static uint8_t functionElse(int token) {
_functionElse:
	CALL	__frameset0
; 1045	    if (!CheckEOL()) {
	CALL	_CheckEOL
	OR	A,A
	JR	NZ,L_468
; 1046	        return E_SYNTAX;
	LD	A,6
	JR	L_469
; 1047	    }
L_468:
; 1048	    return E_ELSE;
	LD	A,3
; 1049	}
L_469:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionElse ***************************
;Name                         Addr/Register   Size   Type
;_CheckEOL                           IMPORT  -----   function
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


; 1050	
; 1051	static uint8_t functionEnd(int token) {
_functionEnd:
	CALL	__frameset0
; 1052	    if (!CheckEOL()) {
	CALL	_CheckEOL
	OR	A,A
	JR	NZ,L_471
; 1053	        return E_SYNTAX;
	LD	A,6
	JR	L_472
; 1054	    }
L_471:
; 1055	    return E_END;
	LD	A,4
; 1056	}
L_472:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionEnd ***************************
;Name                         Addr/Register   Size   Type
;_CheckEOL                           IMPORT  -----   function
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


; 1057	
; 1058	static uint8_t dummyReturn(int token) {
_dummyReturn:
	CALL	__frameset0
; 1059	    return VALID;
	LD	A,255
; 1060	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _dummyReturn ***************************
;Name                         Addr/Register   Size   Type
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


; 1061	
; 1062	bool JumpForward(uint8_t *startAddr, uint8_t *endAddr, uint24_t tempDataOffsetElements, uint8_t tempGotoElements, uint8_t tempLblElements) {
_JumpForward:
	LD	HL,-31
	CALL	__frameset
; 1063	    if (endAddr - startAddr <= 0x80) {
	LD	BC,(IX+6)
	LD	HL,(IX+9)
	OR	A,A
	SBC	HL,BC
	LD	BC,HL
	LD	HL,128
	OR	A,A
	SBC	HL,BC
	JP	M,L_503
; 1064	        uint8_t *tempPtr = startAddr;
	LD	BC,(IX+6)
	LD	(IX+-25),BC
; 1065	        uint8_t opcode = *startAddr;
	LD	HL,(IX+6)
	LD	A,(HL)
	LD	(IX+-4),A
; 1066	        uint24_t tempForLoopSMCElements = ice.ForLoopSMCElements;
	LD	BC,(_ice+3383)
	LD	(IX+-7),BC
; 1067	        label_t *labelPtr = ice.LblStack;
	LD	BC,(_ice+71)
	LD	(IX+-19),BC
; 1068	        label_t *gotoPtr = ice.GotoStack;
	LD	BC,(_ice+74)
	LD	(IX+-22),BC
; 1069	
; 1070	        *startAddr++ = opcode - 0xA2 - (opcode == 0xC3 ? 9 : 0);
	LD	A,(IX+-4)
	CP	A,195
	JR	NZ,L_477
	LD	BC,9
	LD	(IX+-13),BC
	JR	L_478
L_477:
	LD	BC,0
	LD	(IX+-13),BC
L_478:
	LD	A,(IX+-13)
	ADD	A,162
	LD	B,A
	LD	A,(IX+-4)
	SUB	A,B
	LD	HL,(IX+6)
	LD	(HL),A
	LD	BC,(IX+6)
	INC	BC
	LD	(IX+6),BC
; 1071	        *startAddr++ = endAddr - tempPtr - 4;
	LD	BC,(IX+-25)
	LD	HL,(IX+9)
	LD	IY,(IX+6)
	OR	A,A
	SBC	HL,BC
	DEC	HL
	DEC	HL
	DEC	HL
	DEC	HL
	LD	(IY),L
	LD	BC,(IX+6)
	INC	BC
	LD	(IX+6),BC
; 1072	
; 1073	        // Update pointers to data, decrease them all with 2, except pointers from data to data!
; 1074	        while (ice.dataOffsetElements != tempDataOffsetElements) {
	JR	L_484
L_485:
; 1075	            uint8_t *tempDataOffsetStackAddr = (uint8_t*)ice.dataOffsetStack[tempDataOffsetElements];
	LD	HL,(IX+12)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_ice+77
	ADD	HL,BC
	LD	(IX+-16),HL
	LD	BC,(HL)
	LD	(IX+-10),BC
; 1076	
; 1077	            // Check if the pointer is in the program, not in the program data
; 1078	            if (tempDataOffsetStackAddr >= ice.programData && tempDataOffsetStackAddr <= ice.programPtr) {
	OR	A,A
	LD	BC,(_ice+54)
	LD	HL,(IX+-10)
	SBC	HL,BC
	JR	C,L_483
	LD	BC,(IX+-10)
	LD	HL,(_ice+60)
	OR	A,A
	SBC	HL,BC
	JR	C,L_483
; 1079	                ice.dataOffsetStack[tempDataOffsetElements] = (uint24_t*)(tempDataOffsetStackAddr - 2);
	LD	IY,(IX+-10)
	LEA	BC,IY+-2
	LD	HL,(IX+-16)
	LD	(HL),BC
; 1080	            }
L_483:
; 1081	            tempDataOffsetElements++;
	LD	BC,(IX+12)
	INC	BC
	LD	(IX+12),BC
; 1082	        }
L_484:
	LD	BC,(IX+12)
	LD	HL,(_ice+3077)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_485
; 1083	
; 1084	        // Update Goto and Lbl addresses, decrease them all with 2
; 1085	        while (ice.curGoto != tempGotoElements) {
	JR	L_487
L_488:
; 1086	            gotoPtr[tempGotoElements].addr -= 2;
	LD	A,(IX+15)
	UEXT	HL
	LD	L,A
	LD	A,26
	CALL	__imul_b
	LD	A,(IX+15)
	LD	BC,(IX+-22)
	ADD	HL,BC
	LD	IY,HL
	UEXT	HL
	LD	L,A
	LD	A,26
	CALL	__imul_b
	LD	BC,(IX+-22)
	ADD	HL,BC
	LD	IY,(IY+20)
	LEA	BC,IY+-2
	LD	IY,HL
	LD	(IY+20),BC
; 1087	            tempGotoElements++;
	INC	(IX+15)
; 1088	        }
L_487:
	LD	A,(IX+15)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(_ice+10898)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_488
; 1089	        while (ice.curLbl != tempLblElements) {
	JR	L_491
L_492:
; 1090	            labelPtr[tempLblElements].addr -= 2;
	LD	A,(IX+18)
	UEXT	HL
	LD	L,A
	LD	A,26
	CALL	__imul_b
	LD	A,(IX+18)
	LD	BC,(IX+-19)
	ADD	HL,BC
	LD	IY,HL
	UEXT	HL
	LD	L,A
	LD	A,26
	CALL	__imul_b
	LD	BC,(IX+-19)
	ADD	HL,BC
	LD	IY,(IY+20)
	LEA	BC,IY+-2
	LD	IY,HL
	LD	(IY+20),BC
; 1091	            tempLblElements++;
	INC	(IX+18)
; 1092	        }
L_491:
	LD	A,(IX+18)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(_ice+10895)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_492
; 1093	
; 1094	        // Update all the For loop SMC addresses
; 1095	        while (tempForLoopSMCElements--) {
	JR	L_496
L_497:
; 1096	            if ((uint24_t)ice.ForLoopSMCStack[tempForLoopSMCElements] > (uint24_t)startAddr) {
	LD	HL,(IX+-7)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	(IX+-3),HL
	LD	BC,_ice+3083
	ADD	HL,BC
	LD	BC,(HL)
	LD	HL,(IX+6)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_496
; 1097	                *ice.ForLoopSMCStack[tempForLoopSMCElements] -= 2;
	LD	BC,_ice+3083
	LD	(IX+-31),BC
	LD	BC,(IX+-3)
	LD	HL,(IX+-31)
	ADD	HL,BC
	LD	(IX+-28),HL
	LD	BC,(IX+-3)
	LD	HL,(IX+-31)
	ADD	HL,BC
	LD	HL,(HL)
	LD	IY,(HL)
	LD	HL,(IX+-28)
	LD	HL,(HL)
	LEA	BC,IY+-2
	LD	(HL),BC
; 1098	                ice.ForLoopSMCStack[tempForLoopSMCElements] = (uint24_t*)(((uint8_t*)ice.ForLoopSMCStack[tempForLoopSMCElements]) - 2);
	LD	IY,(IX+-28)
	LD	BC,(IX+-3)
	LD	HL,(IX+-31)
	ADD	HL,BC
	LD	IY,(IY)
	LEA	BC,IY+-2
	LD	(HL),BC
; 1099	            }
; 1100	        }
L_496:
	LD	HL,(IX+-7)
	CALL	__icmpzero
	LD	IY,(IX+-7)
	LEA	IY,IY+-1
	LD	(IX+-7),IY
	JR	NZ,L_497
; 1101	
; 1102	        if (ice.programPtr != startAddr) {
	LD	BC,(IX+6)
	LD	HL,(_ice+60)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_501
; 1103	            memmove(startAddr, startAddr + 2, ice.programPtr - startAddr);
	LD	HL,(_ice+60)
	LD	BC,(IX+6)
	OR	A,A
	SBC	HL,BC
	PUSH	HL
	LD	IY,(IX+6)
	LEA	BC,IY+2
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_memmove
	POP	BC
	POP	BC
	POP	BC
; 1104	        }
L_501:
; 1105	        ice.programPtr -= 2;
	LD	IY,(_ice+60)
	LEA	BC,IY+-2
	LD	(_ice+60),BC
; 1106	        
; 1107	        return true;
	LD	A,1
	JR	L_504
; 1108	    } else {
L_503:
; 1109	        w24(startAddr + 1, endAddr - ice.programData + PRGM_START);
	LD	DE,(_ice+54)
	LD	HL,(IX+9)
	LD	IY,(IX+6)
	LD	BC,13740162
; 1110	        
; 1111	        return false;
	XOR	A,A
	OR	A,A
	SBC	HL,DE
	ADD	HL,BC
	LD	(IY+1),HL
; 1112	    }
; 1113	}
L_504:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _JumpForward ***************************
;Name                         Addr/Register   Size   Type
;_memmove                            IMPORT  -----   function
;_ice                                IMPORT  10958   variable
;tempPtr                              IX-25      3   variable
;gotoPtr                              IX-22      3   variable
;labelPtr                             IX-19      3   variable
;G_26                                 IX-16      3   variable
;temp475                              IX-13      3   variable
;tempDataOffsetStackAddr              IX-10      3   variable
;tempForLoopSMCElements                IX-7      3   variable
;opcode                                IX-4      1   variable
;G_28                                  IX-3      3   variable
;tempLblElements                      IX+18      1   parameter
;tempGotoElements                     IX+15      1   parameter
;tempDataOffsetElements               IX+12      3   parameter
;endAddr                               IX+9      3   parameter
;startAddr                             IX+6      3   parameter


; Stack Frame Size: 52 (bytes)
;       Spill Code: 0 (instruction)


; 1114	
; 1115	bool JumpBackwards(uint8_t *startAddr, uint8_t whichOpcode) {
_JumpBackwards:
	LD	HL,-6
	CALL	__frameset
; 1116	    if (ice.programPtr + 2 - startAddr <= 0x80) {
	LD	IY,(_ice+60)
	LEA	HL,IY+2
	LD	BC,(IX+6)
	OR	A,A
	SBC	HL,BC
	LD	BC,HL
	LD	HL,128
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_510
; 1117	        uint8_t *tempPtr = ice.programPtr;
	LD	BC,(_ice+60)
	LD	(IX+-6),BC
; 1118	
; 1119	        OutputWriteByte(whichOpcode);
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
; 1120	        OutputWriteByte(startAddr - 2 - tempPtr);
	LD	IY,(IX+-6)
	LEA	BC,IY+2
	LD	HL,(IX+6)
	OR	A,A
	SBC	HL,BC
	LD	C,L
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
; 1121	
; 1122	        return true;
	LD	A,1
	JR	L_511
; 1123	    } else {
L_510:
; 1124	        // JR cc to JP cc
; 1125	        OutputWriteByte(whichOpcode + 0xA2 + (whichOpcode == 0x18 ? 9 : 0));
	LD	A,(IX+9)
	CP	A,24
	JR	NZ,L_507
	LD	BC,9
	LD	(IX+-3),BC
	JR	L_508
L_507:
	LD	BC,0
	LD	(IX+-3),BC
L_508:
	LD	A,(IX+9)
	ADD	A,162
	LD	B,(IX+-3)
	ADD	A,B
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
; 1126	        OutputWriteLong(startAddr - ice.programData + PRGM_START);
	LD	HL,(IX+6)
	LD	BC,(_ice+54)
	OR	A,A
	SBC	HL,BC
	LD	BC,13740162
	ADD	HL,BC
	PUSH	HL
	CALL	_OutputWriteLong
	POP	BC
; 1127	
; 1128	        return false;
	XOR	A,A
; 1129	    }
; 1130	}
L_511:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _JumpBackwards ***************************
;Name                         Addr/Register   Size   Type
;_OutputWriteLong                    IMPORT  -----   function
;_OutputWriteByte                    IMPORT  -----   function
;_ice                                IMPORT  10958   variable
;tempPtr                               IX-6      3   variable
;temp505                               IX-3      3   variable
;whichOpcode                           IX+9      1   parameter
;startAddr                             IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT DATA
_WhileRepeatCondStart:
	DW24	0
	SEGMENT BSS
_WhileJumpBackwardsLarge:
	DS	1
; 1131	
; 1132	uint8_t *WhileRepeatCondStart = NULL;
; 1133	bool WhileJumpBackwardsLarge;
	SEGMENT CODE
; 1134	
; 1135	static uint8_t functionWhile(int token) {
_functionWhile:
	LD	HL,-19
	CALL	__frameset
; 1136	    uint24_t tempDataOffsetElements = ice.dataOffsetElements;
	LD	BC,(_ice+3077)
	LD	(IX+-7),BC
; 1137	    uint8_t tempGotoElements = ice.curGoto;
	LD	A,(_ice+10898)
	LD	(IX+-3),A
; 1138	    uint8_t tempLblElements = ice.curLbl;
	LD	A,(_ice+10895)
	LD	(IX+-2),A
; 1139	    uint8_t *WhileStartAddr = ice.programPtr, res;
	LD	BC,(_ice+60)
	LD	(IX+-13),BC
; 1140	    uint8_t *WhileRepeatCondStartTemp = WhileRepeatCondStart;
	LD	BC,(_WhileRepeatCondStart)
	LD	(IX+-10),BC
; 1141	    bool WhileJumpForwardSmall;
; 1142	
; 1143	    // Basically the same as "Repeat", but jump to condition checking first
; 1144	    JP(0);
	LD	BC,195
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	BC,0
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
; 1145	    if ((res = functionRepeat(token)) != VALID) {
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_functionRepeat
	POP	BC
	LD	(IX+-1),A
	CP	A,255
	JR	Z,L_516
; 1146	        return res;
	LD	A,(IX+-1)
	JR	L_520
; 1147	    }
L_516:
; 1148	    WhileJumpForwardSmall = JumpForward(WhileStartAddr, WhileRepeatCondStart, tempDataOffsetElements, tempGotoElements, tempLblElements);
	LD	C,(IX+-2)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-3)
	PUSH	BC
	LD	BC,(IX+-7)
	PUSH	BC
	LD	BC,(_WhileRepeatCondStart)
	PUSH	BC
	LD	BC,(IX+-13)
	PUSH	BC
	CALL	_JumpForward
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-4),A
; 1149	    WhileRepeatCondStart = WhileRepeatCondStartTemp;
	LD	BC,(IX+-10)
	LD	(_WhileRepeatCondStart),BC
; 1150	
; 1151	    if (WhileJumpForwardSmall && WhileJumpBackwardsLarge) {
	LD	A,(IX+-4)
	OR	A,A
	JR	Z,L_519
	LD	A,(_WhileJumpBackwardsLarge)
	OR	A,A
	JR	Z,L_519
; 1152	        // Now the JP at the condition points to the 2nd byte after the JR to the condition, so update that too
; 1153	        w24(ice.programPtr - 3, r24(ice.programPtr - 3) - 2);
	LD	IY,(_ice+60)
	LEA	HL,IY+-3
	LD	(IX+-19),HL	; spill
	LD	IY,(_ice+60)
	LEA	HL,IY+-3
	LD	(IX+-16),HL	; spill
	LD	HL,(IX+-19)	; unspill
	LD	IY,(HL)
	LD	HL,(IX+-16)	; unspill
	LEA	BC,IY+-2
	LD	(HL),BC
; 1154	    }
L_519:
; 1155	
; 1156	    return VALID;
	LD	A,255
; 1157	}
L_520:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionWhile ***************************
;Name                         Addr/Register   Size   Type
;_WhileJumpBackwardsLarge            STATIC      1   variable
;_JumpForward                        IMPORT  -----   function
;_functionRepeat                     IMPORT  -----   function
;_OutputWriteLong                    IMPORT  -----   function
;_OutputWriteByte                    IMPORT  -----   function
;_WhileRepeatCondStart               STATIC      3   variable
;_ice                                IMPORT  10958   variable
;WhileStartAddr                       IX-13      3   variable
;WhileRepeatCondStartTemp             IX-10      3   variable
;tempDataOffsetElements                IX-7      3   variable
;WhileJumpForwardSmall                 IX-4      1   variable
;tempGotoElements                      IX-3      1   variable
;tempLblElements                       IX-2      1   variable
;res                                   IX-1      1   variable
;token                                 IX+6      3   parameter


; Stack Frame Size: 28 (bytes)
;       Spill Code: 0 (instruction)


; 1158	
; 1159	uint8_t functionRepeat(int token) {
_functionRepeat:
	LD	HL,-30
	CALL	__frameset
; 1160	    uint24_t tempCurrentLine, tempCurrentLine2;
; 1161	    uint16_t RepeatCondStart, RepeatProgEnd;
; 1162	    uint8_t *RepeatCodeStart, res;
; 1163	
; 1164	    RepeatCondStart = _tell(ice.inPrgm);
	LD	A,(_ice+10904)
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_ti_Tell
	POP	BC
	LD	(IX+-10),L
	LD	(IX+-9),H
; 1165	    RepeatCodeStart = ice.programPtr;
	LD	BC,(_ice+60)
	LD	(IX+-5),BC
; 1166	    tempCurrentLine = ice.currentLine;
	LD	BC,(_ice+3386)
	LD	(IX+-27),BC
; 1167	
; 1168	    // Skip the condition for now
; 1169	    skipLine();
	CALL	_skipLine
; 1170	    ResetAllRegs();
	CALL	_ResetAllRegs
; 1171	
; 1172	    // Parse the code inside the loop
; 1173	    if ((res = parseProgramUntilEnd()) != E_END && res != VALID) {
	CALL	_parseProgramUntilEnd
	LD	(IX+-1),A
	CP	A,4
	JR	Z,L_523
	LD	A,(IX+-1)
	CP	A,255
	JR	Z,L_523
; 1174	        return res;
	LD	A,(IX+-1)
	JR	L_560
; 1175	    }
L_523:
; 1176	
; 1177	    ResetAllRegs();
	CALL	_ResetAllRegs
; 1178	
; 1179	    // Remind where the "End" is
; 1180	    RepeatProgEnd = _tell(ice.inPrgm);
	LD	A,(_ice+10904)
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_ti_Tell
	POP	BC
	LD	(IX+-24),L
	LD	(IX+-23),H
; 1181	    if (token == tWhile) {
	LD	HL,(IX+6)
	LD	BC,209
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_525
; 1182	        WhileRepeatCondStart = ice.programPtr;
	LD	BC,(_ice+60)
	LD	(_WhileRepeatCondStart),BC
; 1183	    }
L_525:
; 1184	
; 1185	    // Parse the condition
; 1186	    _seek(RepeatCondStart, SEEK_SET, ice.inPrgm);
	LD	A,(_ice+10904)
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-10)
	CALL	__stoiu
	PUSH	HL
	CALL	_ti_Seek
	POP	BC
	POP	BC
	POP	BC
; 1187	    tempCurrentLine2 = ice.currentLine;
	LD	BC,(_ice+3386)
	LD	(IX+-30),BC
; 1188	    ice.currentLine = tempCurrentLine;
	LD	BC,(IX+-27)
	LD	(_ice+3386),BC
; 1189	
; 1190	    if ((res = parseExpression(_getc())) != VALID) {
	CALL	_getNextToken
	PUSH	HL
	CALL	_parseExpression
	POP	BC
	LD	(IX+-1),A
	CP	A,255
	JR	Z,L_527
; 1191	        return res;
	LD	A,(IX+-1)
	JR	L_560
; 1192	    }
L_527:
; 1193	    ice.currentLine = tempCurrentLine2;
	LD	BC,(IX+-30)
	LD	(_ice+3386),BC
; 1194	
; 1195	    // And set the pointer after the "End"
; 1196	    _seek(RepeatProgEnd, SEEK_SET, ice.inPrgm);
	LD	A,(_ice+10904)
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+-24)
	CALL	__stoiu
	PUSH	HL
	CALL	_ti_Seek
	POP	BC
	POP	BC
	POP	BC
; 1197	
; 1198	    if (expr.outputIsNumber) {
	LD	A,(_expr+2)
	OR	A,A
	JR	Z,L_539
; 1199	        ice.programPtr -= expr.SizeOfOutputNumber;
	LD	A,(_expr+12)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(_ice+60)
	OR	A,A
	SBC	HL,BC
	LD	(_ice+60),HL
; 1200	        if ((expr.outputNumber && (uint8_t)token == tWhile) || (!expr.outputNumber && (uint8_t)token == tRepeat)) {
	LD	HL,(_expr+13)
	CALL	__icmpzero
	JR	Z,L_530
	LD	A,(IX+6)
	CP	A,209
	JR	Z,L_535
L_530:
	LD	HL,(_expr+13)
	CALL	__icmpzero
	JR	NZ,L_536
	LD	A,(IX+6)
	CP	A,210
	JR	NZ,L_536
L_535:
; 1201	            WhileJumpBackwardsLarge = !JumpBackwards(RepeatCodeStart, OP_JR);
	LD	BC,24
	PUSH	BC
	LD	BC,(IX+-5)
	PUSH	BC
	CALL	_JumpBackwards
	POP	BC
	POP	BC
	OR	A,A
	JR	NZ,L_532
	LD	BC,1
	LD	(IX+-8),BC
	JR	L_533
L_532:
	LD	BC,0
	LD	(IX+-8),BC
L_533:
	LD	A,(IX+-8)
	LD	(_WhileJumpBackwardsLarge),A
; 1202	        }
L_536:
; 1203	        return VALID;
	LD	A,255
	JR	L_560
; 1204	    }
L_539:
; 1205	
; 1206	    if (expr.outputIsString) {
	LD	A,(_expr+4)
	OR	A,A
	JR	Z,L_540
; 1207	        return E_SYNTAX;
	LD	A,6
	JR	L_560
; 1208	    }
L_540:
; 1209	
; 1210	    optimizeZeroCarryFlagOutput();
	CALL	_optimizeZeroCarryFlagOutput
; 1211	
; 1212	    if ((uint8_t)token == tWhile) {
	LD	A,(IX+6)
	CP	A,209
	JR	NZ,L_559
; 1213	        // Switch the flags
; 1214	        bool a = expr.AnsSetZeroFlag;
	LD	A,(_expr+5)
	LD	(IX+-2),A
; 1215	
; 1216	        expr.AnsSetZeroFlag = expr.AnsSetZeroFlagReversed;
	LD	A,(_expr+6)
	LD	(_expr+5),A
; 1217	        expr.AnsSetZeroFlagReversed = a;
	LD	A,(IX+-2)
	LD	(_expr+6),A
; 1218	        a = expr.AnsSetCarryFlag;
	LD	A,(_expr+7)
	LD	(IX+-2),A
; 1219	        expr.AnsSetCarryFlag = expr.AnsSetCarryFlagReversed;
	LD	A,(_expr+8)
	LD	(_expr+7),A
; 1220	        expr.AnsSetCarryFlagReversed = a;
	LD	A,(IX+-2)
	LD	(_expr+8),A
; 1221	    }
L_559:
; 1222	
; 1223	    WhileJumpBackwardsLarge = !JumpBackwards(RepeatCodeStart, expr.AnsSetCarryFlag || expr.AnsSetCarryFlagReversed ?
	LD	A,(_expr+7)
	OR	A,A
	JR	NZ,L_552
	LD	A,(_expr+8)
	OR	A,A
	JR	Z,L_553
; 1224	        (expr.AnsSetCarryFlagReversed ? OP_JR_NC : OP_JR_C) :
L_552:
	LD	A,(_expr+8)
	OR	A,A
	JR	Z,L_545
	LD	BC,48
	LD	(IX+-16),BC
	JR	L_546
L_545:
	LD	BC,56
	LD	(IX+-16),BC
L_546:
; 1225	        (expr.AnsSetZeroFlagReversed  ? OP_JR_NZ : OP_JR_Z));
	LD	BC,(IX+-16)
	LD	(IX+-13),BC
	JR	L_554
L_553:
	LD	A,(_expr+6)
	OR	A,A
	JR	Z,L_549
	LD	BC,32
	LD	(IX+-19),BC
	JR	L_550
L_549:
	LD	BC,40
	LD	(IX+-19),BC
L_550:
	LD	BC,(IX+-19)
	LD	(IX+-13),BC
L_554:
	LD	C,(IX+-13)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-5)
	PUSH	BC
	CALL	_JumpBackwards
	POP	BC
	POP	BC
	OR	A,A
	JR	NZ,L_556
	LD	BC,1
	LD	(IX+-22),BC
	JR	L_557
L_556:
	LD	BC,0
	LD	(IX+-22),BC
L_557:
	LD	A,(IX+-22)
	LD	(_WhileJumpBackwardsLarge),A
; 1226	    return VALID;
	LD	A,255
; 1227	}
L_560:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionRepeat ***************************
;Name                         Addr/Register   Size   Type
;_optimizeZeroCarryFlagOutput        IMPORT  -----   function
;_WhileJumpBackwardsLarge            STATIC      1   variable
;_JumpBackwards                      IMPORT  -----   function
;_expr                               IMPORT     16   variable
;_getNextToken                       IMPORT  -----   function
;_ti_Seek                            IMPORT  -----   function
;_WhileRepeatCondStart               STATIC      3   variable
;_parseProgramUntilEnd               IMPORT  -----   function
;_ResetAllRegs                       IMPORT  -----   function
;_skipLine                           IMPORT  -----   function
;_ice                                IMPORT  10958   variable
;_ti_Tell                            IMPORT  -----   function
;tempCurrentLine2                     IX-30      3   variable
;tempCurrentLine                      IX-27      3   variable
;RepeatProgEnd                        IX-24      2   variable
;temp558                              IX-22      3   variable
;temp547                              IX-19      3   variable
;temp543                              IX-16      3   variable
;temp551                              IX-13      3   variable
;RepeatCondStart                      IX-10      2   variable
;temp534                               IX-8      3   variable
;RepeatCodeStart                       IX-5      3   variable
;a                                     IX-2      1   variable
;res                                   IX-1      1   variable
;token                                 IX+6      3   parameter


; Stack Frame Size: 39 (bytes)
;       Spill Code: 0 (instruction)


; 1228	
; 1229	static uint8_t functionReturn(int token) {
_functionReturn:
	LD	HL,-10
	CALL	__frameset
; 1230	    uint8_t res;
; 1231	
; 1232	    if ((token = _getc()) == EOF || (uint8_t)token == tEnter || (uint8_t)token == tColon) {
	CALL	_getNextToken
	LD	(IX+6),HL
	LD	BC,16777215
	OR	A,A
	SBC	HL,BC
	JR	Z,L_585
	LD	A,(IX+6)
	CP	A,63
	JR	Z,L_585
	LD	A,(IX+6)
	CP	A,62
	JR	NZ,L_586
L_585:
; 1233	        RET();
	LD	BC,201
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
; 1234	        ice.lastTokenIsReturn = true;
	LD	A,1
	LD	(_ice+10907),A
; 1235	    } else if (token == tIf) {
	JR	L_587
L_586:
	LD	BC,206
	LD	HL,(IX+6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_584
; 1236	        if ((res = parseExpression(_getc())) != VALID) {
	CALL	_getNextToken
	PUSH	HL
	CALL	_parseExpression
	POP	BC
	LD	(IX+-1),A
	CP	A,255
	JR	Z,L_568
; 1237	            return res;
	LD	A,(IX+-1)
	JR	L_588
; 1238	        }
L_568:
; 1239	        if (expr.outputIsString) {
	LD	A,(_expr+4)
	OR	A,A
	JR	Z,L_569
; 1240	            return E_SYNTAX;
	LD	A,6
	JR	L_588
; 1241	        }
L_569:
; 1242	
; 1243	        //Check if we can optimize stuff :D
; 1244	        optimizeZeroCarryFlagOutput();
	CALL	_optimizeZeroCarryFlagOutput
; 1245	
; 1246	        OutputWriteByte((expr.AnsSetCarryFlag || expr.AnsSetCarryFlagReversed ?
	LD	A,(_expr+7)
	OR	A,A
	JR	NZ,L_580
	LD	A,(_expr+8)
	OR	A,A
	JR	Z,L_581
; 1247	            (expr.AnsSetCarryFlagReversed ? OP_RET_C : OP_RET_NC) :
L_580:
	LD	A,(_expr+8)
	OR	A,A
	JR	Z,L_573
	LD	BC,216
	LD	(IX+-4),BC
	JR	L_574
L_573:
	LD	BC,208
	LD	(IX+-4),BC
L_574:
; 1248	            (expr.AnsSetZeroFlagReversed ? OP_RET_Z : OP_RET_NZ)));
	LD	BC,(IX+-4)
	LD	(IX+-10),BC
	JR	L_582
L_581:
	LD	A,(_expr+6)
	OR	A,A
	JR	Z,L_577
	LD	BC,200
	LD	(IX+-7),BC
	JR	L_578
L_577:
	LD	BC,192
	LD	(IX+-7),BC
L_578:
	LD	BC,(IX+-7)
	LD	(IX+-10),BC
L_582:
	LD	C,(IX+-10)
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
; 1249	    } else {
	JR	L_587
L_584:
; 1250	        return E_SYNTAX;
	LD	A,6
	JR	L_588
; 1251	    }
L_587:
; 1252	    return VALID;
	LD	A,255
; 1253	}
L_588:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionReturn ***************************
;Name                         Addr/Register   Size   Type
;_optimizeZeroCarryFlagOutput        IMPORT  -----   function
;_expr                               IMPORT     16   variable
;_ice                                IMPORT  10958   variable
;_OutputWriteByte                    IMPORT  -----   function
;_getNextToken                       IMPORT  -----   function
;temp579                              IX-10      3   variable
;temp575                               IX-7      3   variable
;temp571                               IX-4      3   variable
;res                                   IX-1      1   variable
;token                                 IX+6      3   parameter


; Stack Frame Size: 19 (bytes)
;       Spill Code: 0 (instruction)


; 1254	
; 1255	static uint8_t functionDisp(int token) {
_functionDisp:
	LD	HL,-7
	CALL	__frameset
; 1256	    do {
L_603:
; 1257	        uint8_t res;
; 1258	
; 1259	        if ((uint8_t)(token = _getc()) == tii) {
	CALL	_getNextToken
	LD	(IX+6),HL
	LD	A,(IX+6)
	CP	A,44
	JR	NZ,L_597
; 1260	            if ((token = _getc()) == EOF) {
	CALL	_getNextToken
	LD	(IX+6),HL
	LD	BC,16777215
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_590
; 1261	                ice.tempToken = tEnter;
	LD	A,63
	LD	(_ice+69),A
; 1262	            } else {
	JR	L_593
L_590:
; 1263	                ice.tempToken = (uint8_t)token;
	LD	A,(IX+6)
	LD	(_ice+69),A
; 1264	            }
L_593:
; 1265	            CALL(_NewLine);
	LD	BC,205
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	BC,133104
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
	JR	L_594
; 1266	            goto checkArgument;
; 1267	        }
L_597:
; 1268	
; 1269	        // Get the argument, and display it, based on whether it's a string or the outcome of an expression
; 1270	        expr.inFunction = true;
	LD	A,1
	LD	(_expr+1),A
; 1271	        if ((res = parseExpression(token)) != VALID) {
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_parseExpression
	POP	BC
	LD	(IX+-1),A
	CP	A,255
	JR	Z,L_599
; 1272	            return res;
	LD	A,(IX+-1)
	JR	L_606
; 1273	        }
L_599:
; 1274	
; 1275	        AnsToHL();
	CALL	_AnsToHL
; 1276	        CallRoutine(&ice.usedAlreadyDisp, &ice.DispAddr, (uint8_t*)DispData, SIZEOF_DISP_DATA);
	LD	BC,26
	PUSH	BC
	LD	BC,_DispData
	PUSH	BC
	LD	BC,_ice+10955
	PUSH	BC
	LD	BC,_ice+10954
	PUSH	BC
	CALL	_CallRoutine
	POP	BC
	POP	BC
	POP	BC
	POP	BC
; 1277	        if (!expr.outputIsString) {
	LD	A,(_expr+4)
	OR	A,A
	JR	NZ,L_594
; 1278	            w24(ice.programPtr - 3, r24(ice.programPtr - 3) + 13);
	LD	IY,(_ice+60)
	LEA	HL,IY+-3
	LD	(IX+-7),HL	; spill
	LD	IY,(_ice+60)
	LEA	HL,IY+-3
	LD	(IX+-4),HL	; spill
	LD	HL,(IX+-7)	; unspill
	LD	IY,(HL)
	LD	HL,(IX+-4)	; unspill
	LEA	BC,IY+13
	LD	(HL),BC
L_594:
; 1279	        }
; 1280	
; 1281	checkArgument:
; 1282	        ResetAllRegs();
	CALL	_ResetAllRegs
; 1283	
; 1284	        // Oops, there was a ")" after the expression
; 1285	        if (ice.tempToken == tRParen) {
	LD	A,(_ice+69)
	CP	A,17
	JR	NZ,L_604
; 1286	            return E_SYNTAX;
	LD	A,6
	JR	L_606
; 1287	        }
; 1288	    } while (ice.tempToken != tEnter);
L_604:
	LD	A,(_ice+69)
	CP	A,63
	JR	NZ,L_603
; 1289	
; 1290	    return VALID;
	LD	A,255
; 1291	}
L_606:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionDisp ***************************
;Name                         Addr/Register   Size   Type
;_ResetAllRegs                       IMPORT  -----   function
;_DispData                           IMPORT  -----   function
;_CallRoutine                        IMPORT  -----   function
;_AnsToHL                            IMPORT  -----   function
;_expr                               IMPORT     16   variable
;_OutputWriteLong                    IMPORT  -----   function
;_OutputWriteByte                    IMPORT  -----   function
;_ice                                IMPORT  10958   variable
;_getNextToken                       IMPORT  -----   function
;res                                   IX-1      1   variable
;token                                 IX+6      3   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


; 1292	
; 1293	static uint8_t functionOutput(int token) {
_functionOutput:
	LD	HL,-8
	CALL	__frameset
; 1294	    uint8_t res;
; 1295	
; 1296	    // Get the first argument = column
; 1297	    expr.inFunction = true;
	LD	A,1
	LD	(_expr+1),A
; 1298	    if ((res = parseExpression(_getc())) != VALID) {
	CALL	_getNextToken
	PUSH	HL
	CALL	_parseExpression
	POP	BC
	LD	(IX+-1),A
	CP	A,255
	JR	Z,L_610
; 1299	        return res;
	LD	A,(IX+-1)
	JR	L_684
; 1300	    }
L_610:
; 1301	
; 1302	    // Return syntax error if the expression was a string or the token after the expression wasn't a comma
; 1303	    if (expr.outputIsString || ice.tempToken != tComma) {
	LD	A,(_expr+4)
	OR	A,A
	JR	NZ,L_609
	LD	A,(_ice+69)
	CP	A,43
	JR	Z,L_673
L_609:
; 1304	        return E_SYNTAX;
	LD	A,6
	JR	L_684
; 1305	    }
L_673:
; 1306	
; 1307	    if (expr.outputIsNumber) {
	LD	A,(_expr+2)
	OR	A,A
	JR	Z,L_672
; 1308	        uint8_t outputNumber = expr.outputNumber;
	LD	A,(_expr+13)
	LD	(IX+-2),A
; 1309	
; 1310	        ice.programPtr -= expr.SizeOfOutputNumber;
	LD	A,(_expr+12)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(_ice+60)
; 1311	        LD_A(outputNumber);
	LD	DE,62
	PUSH	DE
	OR	A,A
	SBC	HL,BC
	LD	(_ice+60),HL
	CALL	_OutputWriteByte
	POP	BC
	LD	C,(IX+-2)
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	A,1
	LD	(_reg+6),A
	XOR	A,A
	LD	(_reg+7),A
	LD	A,(IX+-2)
; 1312	        LD_IMM_A(curRow);
	LD	BC,50
	PUSH	BC
	LD	(_reg+13),A
	CALL	_OutputWriteByte
	POP	BC
	LD	BC,13632917
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
; 1313	
; 1314	        // Get the second argument = row
; 1315	        expr.inFunction = true;
	LD	A,1
	LD	(_expr+1),A
; 1316	        if ((res = parseExpression(_getc())) != VALID) {
	CALL	_getNextToken
	PUSH	HL
	CALL	_parseExpression
	POP	BC
	LD	(IX+-1),A
	CP	A,255
	JR	Z,L_619
; 1317	            return res;
	LD	A,(IX+-1)
	JR	L_684
; 1318	        }
L_619:
; 1319	        if (expr.outputIsString) {
	LD	A,(_expr+4)
	OR	A,A
	JR	Z,L_639
; 1320	            return E_SYNTAX;
	LD	A,6
	JR	L_684
; 1321	        }
L_639:
; 1322	
; 1323	        // Yay, we can optimize things!
; 1324	        if (expr.outputIsNumber) {
	LD	A,(_expr+2)
	OR	A,A
	JR	Z,L_638
; 1325	            // Output coordinates in H and L, 6 = sizeof(ld a, X \ ld (curRow), a)
; 1326	            ice.programPtr -= 6 + expr.SizeOfOutputNumber;
	LD	A,(_expr+12)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	BC,IY+6
	LD	HL,(_ice+60)
; 1327	            LD_SIS_HL((expr.outputNumber << 8) + outputNumber);
	LD	DE,8512
	PUSH	DE
	OR	A,A
	SBC	HL,BC
	LD	(_ice+60),HL
	CALL	_OutputWriteWord
	POP	BC
	LD	HL,(_expr+13)
	LD	H,L
	LD	C,(IX+-2)
	LD	B,0
	LD	L,0
	ADD.SIS	HL,BC
	PUSH	HL
	CALL	_OutputWriteWord
	POP	BC
	CALL	_ResetHL
; 1328	            LD_SIS_IMM_HL(curRow & 0xFFFF);
	LD	BC,8768
	PUSH	BC
	CALL	_OutputWriteWord
	POP	BC
	LD	BC,1429
	PUSH	BC
	CALL	_OutputWriteWord
	POP	BC
	JR	L_679
; 1329	        } else {
L_638:
; 1330	            if (expr.outputIsVariable) {
	LD	A,(_expr+3)
	OR	A,A
	JR	Z,L_633
; 1331	                *(ice.programPtr - 2) = OP_LD_A_HL;
	LD	IY,(_ice+60)
	LEA	HL,IY+-2
	LD	(HL),126
; 1332	            } else if (expr.outputRegister == REGISTER_HL) {
	JR	L_636
L_633:
	LD	A,(_expr+10)
	OR	A,A
	JR	NZ,L_631
; 1333	                LD_A_L();
	LD	BC,125
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	CALL	_ResetA
	JR	L_636
; 1334	            } else if (expr.outputRegister == REGISTER_DE) {
L_631:
	LD	A,(_expr+10)
	CP	A,1
	JR	NZ,L_636
; 1335	                LD_A_E();
	LD	BC,123
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	CALL	_ResetA
; 1336	            }
L_636:
; 1337	            LD_IMM_A(curCol);
	LD	BC,50
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	BC,13632918
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
	JR	L_679
; 1338	        }
; 1339	    } else {
L_672:
; 1340	        if (expr.outputIsVariable) {
	LD	A,(_expr+3)
	OR	A,A
	JR	Z,L_648
; 1341	            *(ice.programPtr - 2) = OP_LD_A_HL;
	LD	IY,(_ice+60)
	LEA	HL,IY+-2
	LD	(HL),126
; 1342	        } else if (expr.outputRegister == REGISTER_HL) {
	JR	L_651
L_648:
	LD	A,(_expr+10)
	OR	A,A
	JR	NZ,L_646
; 1343	            LD_A_L();
	LD	BC,125
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	CALL	_ResetA
	JR	L_651
; 1344	        } else if (expr.outputRegister == REGISTER_DE) {
L_646:
	LD	A,(_expr+10)
	CP	A,1
	JR	NZ,L_651
; 1345	            LD_A_E();
	LD	BC,123
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	CALL	_ResetA
; 1346	        }
L_651:
; 1347	        LD_IMM_A(curRow);
	LD	BC,50
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	BC,13632917
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
; 1348	
; 1349	        // Get the second argument = row
; 1350	        expr.inFunction = true;
	LD	A,1
	LD	(_expr+1),A
; 1351	        if ((res = parseExpression(_getc())) != VALID) {
	CALL	_getNextToken
	PUSH	HL
	CALL	_parseExpression
	POP	BC
	LD	(IX+-1),A
	CP	A,255
	JR	Z,L_655
; 1352	            return res;
	LD	A,(IX+-1)
	JR	L_684
; 1353	        }
L_655:
; 1354	        if (expr.outputIsString) {
	LD	A,(_expr+4)
	OR	A,A
	JR	Z,L_667
; 1355	            return E_SYNTAX;
	LD	A,6
	JR	L_684
; 1356	        }
L_667:
; 1357	
; 1358	        if (expr.outputIsNumber) {
	LD	A,(_expr+2)
	OR	A,A
	JR	Z,L_666
; 1359	            *(ice.programPtr - 4) = OP_LD_A;
	LD	IY,(_ice+60)
	LEA	HL,IY+-4
	LD	(HL),62
; 1360	            ice.programPtr -= 2;
	LD	IY,(_ice+60)
	LEA	BC,IY+-2
	LD	(_ice+60),BC
; 1361	        } else if (expr.outputIsVariable) {
	JR	L_670
L_666:
	LD	A,(_expr+3)
	OR	A,A
	JR	Z,L_664
; 1362	            *(ice.programPtr - 2) = OP_LD_A_HL;
	LD	IY,(_ice+60)
	LEA	HL,IY+-2
	LD	(HL),126
; 1363	        } else if (expr.outputRegister == REGISTER_HL) {
	JR	L_670
L_664:
	LD	A,(_expr+10)
	OR	A,A
	JR	NZ,L_662
; 1364	            LD_A_L();
	LD	BC,125
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	CALL	_ResetA
	JR	L_670
; 1365	        } else if (expr.outputRegister == REGISTER_DE) {
L_662:
	LD	A,(_expr+10)
	CP	A,1
	JR	NZ,L_670
; 1366	            LD_A_E();
	LD	BC,123
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	CALL	_ResetA
; 1367	        }
L_670:
; 1368	        LD_IMM_A(curCol);
	LD	BC,50
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	BC,13632918
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
; 1369	    }
L_679:
; 1370	
; 1371	    // Get the third argument = output thing
; 1372	    if (ice.tempToken == tComma) {
	LD	A,(_ice+69)
	CP	A,43
	JR	NZ,L_682
; 1373	        expr.inFunction = true;
	LD	A,1
	LD	(_expr+1),A
; 1374	        if ((res = parseExpression(_getc())) != VALID) {
	CALL	_getNextToken
	PUSH	HL
	CALL	_parseExpression
	POP	BC
	LD	(IX+-1),A
	CP	A,255
	JR	Z,L_675
; 1375	            return res;
	LD	A,(IX+-1)
	JR	L_684
; 1376	        }
L_675:
; 1377	        
; 1378	        AnsToHL();
	CALL	_AnsToHL
; 1379	        CallRoutine(&ice.usedAlreadyDisp, &ice.DispAddr, (uint8_t*)DispData, SIZEOF_DISP_DATA);
	LD	BC,26
	PUSH	BC
	LD	BC,_DispData
	PUSH	BC
	LD	BC,_ice+10955
	PUSH	BC
	LD	BC,_ice+10954
	PUSH	BC
	CALL	_CallRoutine
	POP	BC
	POP	BC
	POP	BC
	POP	BC
; 1380	        if (!expr.outputIsString) {
	LD	A,(_expr+4)
	OR	A,A
	JR	NZ,L_677
; 1381	            w24(ice.programPtr - 3, r24(ice.programPtr - 3) + 13);
	LD	IY,(_ice+60)
	LEA	HL,IY+-3
	LD	(IX+-8),HL	; spill
	LD	IY,(_ice+60)
	LEA	HL,IY+-3
	LD	(IX+-5),HL	; spill
	LD	HL,(IX+-8)	; unspill
	LD	IY,(HL)
	LD	HL,(IX+-5)	; unspill
	LEA	BC,IY+13
	LD	(HL),BC
; 1382	        }
L_677:
; 1383	        ResetAllRegs();
	CALL	_ResetAllRegs
; 1384	    }
L_682:
; 1385	    
; 1386	    if (ice.tempToken != tRParen && ice.tempToken != tEnter) {
	LD	A,(_ice+69)
	CP	A,17
	JR	Z,L_683
	LD	A,(_ice+69)
	CP	A,63
	JR	Z,L_683
; 1387	        return E_SYNTAX;
	LD	A,6
	JR	L_684
; 1388	    }
L_683:
; 1389	
; 1390	    return VALID;
	LD	A,255
; 1391	}
L_684:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionOutput ***************************
;Name                         Addr/Register   Size   Type
;_ResetAllRegs                       IMPORT  -----   function
;_DispData                           IMPORT  -----   function
;_CallRoutine                        IMPORT  -----   function
;_AnsToHL                            IMPORT  -----   function
;_ResetA                             IMPORT  -----   function
;_ResetHL                            IMPORT  -----   function
;_OutputWriteWord                    IMPORT  -----   function
;_OutputWriteLong                    IMPORT  -----   function
;_reg                                IMPORT     28   variable
;_OutputWriteByte                    IMPORT  -----   function
;_ice                                IMPORT  10958   variable
;_getNextToken                       IMPORT  -----   function
;_expr                               IMPORT     16   variable
;outputNumber                          IX-2      1   variable
;res                                   IX-1      1   variable
;token                                 IX+6      3   parameter


; Stack Frame Size: 17 (bytes)
;       Spill Code: 0 (instruction)


; 1392	
; 1393	static uint8_t functionClrHome(int token) {
_functionClrHome:
	CALL	__frameset0
; 1394	    if (!CheckEOL()) {
	CALL	_CheckEOL
	OR	A,A
	JR	NZ,L_686
; 1395	        return E_SYNTAX;
	LD	A,6
	JR	L_693
; 1396	    }
L_686:
; 1397	    MaybeLDIYFlags();
	CALL	_MaybeLDIYFlags
; 1398	    CALL(_HomeUp);
	LD	BC,205
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	BC,133160
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
; 1399	    CALL(_ClrLCDFull);
	LD	BC,205
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	BC,133128
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
; 1400	    ResetAllRegs();
	CALL	_ResetAllRegs
; 1401	
; 1402	    return VALID;
	LD	A,255
; 1403	}
L_693:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionClrHome ***************************
;Name                         Addr/Register   Size   Type
;_ResetAllRegs                       IMPORT  -----   function
;_OutputWriteLong                    IMPORT  -----   function
;_OutputWriteByte                    IMPORT  -----   function
;_MaybeLDIYFlags                     IMPORT  -----   function
;_CheckEOL                           IMPORT  -----   function
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


; 1404	
; 1405	static uint8_t functionFor(int token) {
_functionFor:
	LD	HL,-49
	CALL	__frameset
; 1406	    bool endPointIsNumber = false, stepIsNumber = false, reversedCond = false, smallCode;
	LD	(IX+-10),0
	LD	(IX+-7),0
	LD	(IX+-9),0
; 1407	    uint24_t endPointNumber = 0, stepNumber = 0, tempDataOffsetElements;
	LD	BC,0
	LD	(IX+-17),BC
	LD	(IX+-6),BC
; 1408	    uint8_t tempGotoElements = ice.curGoto;
	LD	A,(_ice+10898)
	LD	(IX+-19),A
; 1409	    uint8_t tempLblElements = ice.curLbl;
	LD	A,(_ice+10895)
	LD	(IX+-11),A
; 1410	    uint8_t *endPointExpressionValue = 0, *stepExpression = 0, *jumpToCond, *loopStart;
	LD	(IX+-14),BC
	LD	(IX+-28),BC
; 1411	    uint8_t tok, variable, res;
; 1412	
; 1413	    if ((tok = _getc()) < tA || tok > tTheta) {
	CALL	_getNextToken
	LD	(IX+-8),L
	LD	A,(IX+-8)
	CP	A,65
	JR	C,L_695
	LD	A,91
	CP	A,(IX+-8)
	JR	NC,L_696
L_695:
; 1414	        return E_SYNTAX;
	LD	A,6
	JR	L_812
; 1415	    }
L_696:
; 1416	    variable = GetVariableOffset(tok);
	LD	C,(IX+-8)
	LD	B,0
	PUSH	BC
	CALL	_GetVariableOffset
	POP	BC
	LD	(IX+-3),A
; 1417	    expr.inFunction = true;
	LD	A,1
	LD	(_expr+1),A
; 1418	    if (_getc() != tComma) {
	CALL	_getNextToken
	LD	BC,43
	OR	A,A
	SBC	HL,BC
	JR	Z,L_699
; 1419	        return E_SYNTAX;
	LD	A,6
	JR	L_812
; 1420	    }
L_699:
; 1421	
; 1422	    // Get the start value, followed by a comma
; 1423	    if ((res = parseExpression(_getc())) != VALID) {
	CALL	_getNextToken
	PUSH	HL
	CALL	_parseExpression
	POP	BC
	LD	(IX+-1),A
	CP	A,255
	JR	Z,L_701
; 1424	        return res;
	LD	A,(IX+-1)
	JR	L_812
; 1425	    }
L_701:
; 1426	    if (ice.tempToken != tComma) {
	LD	A,(_ice+69)
	CP	A,43
	JR	Z,L_702
; 1427	        return E_SYNTAX;
	LD	A,6
	JR	L_812
; 1428	    }
L_702:
; 1429	
; 1430	    // Load the value in the variable
; 1431	    MaybeAToHL();
	CALL	_MaybeAToHL
; 1432	    if (expr.outputRegister == REGISTER_HL) {
	LD	A,(_expr+10)
	OR	A,A
	JR	NZ,L_708
; 1433	        LD_IX_OFF_IND_HL(variable);
	LD	BC,12253
	PUSH	BC
	CALL	_OutputWriteWord
	POP	BC
	LD	C,(IX+-3)
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	A,1
	LD	(_reg+1),A
	LD	A,(IX+-3)
	LD	(_reg+10),A
	JR	L_709
; 1434	    } else {
L_708:
; 1435	        LD_IX_OFF_IND_DE(variable);
	LD	BC,8157
	PUSH	BC
	CALL	_OutputWriteWord
	POP	BC
	LD	C,(IX+-3)
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	A,1
	LD	(_reg+3),A
	LD	A,(IX+-3)
	LD	(_reg+11),A
; 1436	    }
L_709:
; 1437	
; 1438	    // Get the end value
; 1439	    expr.inFunction = true;
	LD	A,1
	LD	(_expr+1),A
; 1440	    if ((res = parseExpression(_getc())) != VALID) {
	CALL	_getNextToken
	PUSH	HL
	CALL	_parseExpression
	POP	BC
	LD	(IX+-1),A
	CP	A,255
	JR	Z,L_715
; 1441	        return res;
	LD	A,(IX+-1)
	JR	L_812
; 1442	    }
L_715:
; 1443	
; 1444	    // If the end point is a number, we can optimize things :D
; 1445	    if (expr.outputIsNumber) {
	LD	A,(_expr+2)
	OR	A,A
	JR	Z,L_714
; 1446	        endPointIsNumber = true;
	LD	(IX+-10),1
; 1447	        endPointNumber = expr.outputNumber;
	LD	BC,(_expr+13)
	LD	(IX+-17),BC
; 1448	        ice.programPtr -= expr.SizeOfOutputNumber;
	LD	A,(_expr+12)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(_ice+60)
	OR	A,A
	SBC	HL,BC
	LD	(_ice+60),HL
; 1449	    } else {
	JR	L_726
L_714:
; 1450	        AnsToHL();
	CALL	_AnsToHL
; 1451	        endPointExpressionValue = ice.programPtr;
	LD	BC,(_ice+60)
	LD	(IX+-14),BC
; 1452	        LD_ADDR_HL(0);
	LD	BC,34
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	BC,0
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
; 1453	    }
L_726:
; 1454	
; 1455	    // Check if there was a step
; 1456	    if (ice.tempToken == tComma) {
	LD	A,(_ice+69)
	CP	A,43
	JR	NZ,L_725
; 1457	        expr.inFunction = true;
	LD	A,1
	LD	(_expr+1),A
; 1458	
; 1459	        // Get the step value
; 1460	        if ((res = parseExpression(_getc())) != VALID) {
	CALL	_getNextToken
	PUSH	HL
	CALL	_parseExpression
	POP	BC
	LD	(IX+-1),A
	CP	A,255
	JR	Z,L_718
; 1461	            return res;
	LD	A,(IX+-1)
	JR	L_812
; 1462	        }
L_718:
; 1463	        if (ice.tempToken == tComma) {
	LD	A,(_ice+69)
	CP	A,43
	JR	NZ,L_723
; 1464	            return E_SYNTAX;
	LD	A,6
	JR	L_812
; 1465	        }
L_723:
; 1466	
; 1467	        if (expr.outputIsNumber) {
	LD	A,(_expr+2)
	OR	A,A
	JR	Z,L_722
; 1468	            stepIsNumber = true;
	LD	(IX+-7),1
; 1469	            stepNumber = expr.outputNumber;
	LD	BC,(_expr+13)
	LD	(IX+-6),BC
; 1470	            ice.programPtr -= expr.SizeOfOutputNumber;
	LD	A,(_expr+12)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(_ice+60)
	OR	A,A
	SBC	HL,BC
	LD	(_ice+60),HL
; 1471	        } else {
	JR	L_727
L_722:
; 1472	            AnsToHL();
	CALL	_AnsToHL
; 1473	            stepExpression = ice.programPtr;
	LD	BC,(_ice+60)
	LD	(IX+-28),BC
; 1474	            LD_ADDR_HL(0);
	LD	BC,34
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	BC,0
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
	JR	L_727
; 1475	        }
; 1476	    } else {
L_725:
; 1477	        stepIsNumber = true;
	LD	(IX+-7),1
; 1478	        stepNumber = 1;
	LD	BC,1
	LD	(IX+-6),BC
; 1479	    }
L_727:
; 1480	
; 1481	    jumpToCond = ice.programPtr;
	LD	BC,(_ice+60)
	LD	(IX+-31),BC
; 1482	    JP(0);
	LD	BC,195
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	BC,0
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
; 1483	    tempDataOffsetElements = ice.dataOffsetElements;
	LD	BC,(_ice+3077)
	LD	(IX+-37),BC
; 1484	    loopStart = ice.programPtr;
	LD	BC,(_ice+60)
	LD	(IX+-34),BC
; 1485	    ResetAllRegs();
	CALL	_ResetAllRegs
; 1486	
; 1487	    // Parse the inner loop
; 1488	    if ((res = parseProgramUntilEnd()) != E_END && res != VALID) {
	CALL	_parseProgramUntilEnd
	LD	(IX+-1),A
	CP	A,4
	JR	Z,L_770
	LD	A,(IX+-1)
	CP	A,255
	JR	Z,L_770
; 1489	        return res;
	LD	A,(IX+-1)
	JR	L_812
; 1490	    }
L_770:
; 1491	
; 1492	    // First add the step to the variable, if the step is 0 we don't need this
; 1493	    if (!stepIsNumber || stepNumber) {
	LD	A,(IX+-7)
	OR	A,A
	JR	Z,L_769
	LD	HL,(IX+-6)
	CALL	__icmpzero
	JR	Z,L_771
L_769:
; 1494	        // ld hl, (ix+*) \ inc hl/dec hl (x times) \ ld (ix+*), hl
; 1495	        // ld hl, (ix+*) \ ld de, x \ add hl, de \ ld (ix+*), hl
; 1496	
; 1497	        LD_HL_IND_IX_OFF(variable);
	LD	C,(IX+-3)
	LD	B,0
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_LoadRegVariable
	POP	BC
	POP	BC
; 1498	        if (stepIsNumber) {
	LD	A,(IX+-7)
	OR	A,A
	JR	Z,L_764
; 1499	            uint8_t a = 0;
; 1500	
; 1501	            if (stepNumber < 5) {
	LD	BC,5
	LD	HL,(IX+-6)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_756
; 1502	                for (a = 0; a < (uint8_t)stepNumber; a++) {
	LD	(IX+-2),0
	JR	L_741
L_739:
; 1503	                    INC_HL();
	LD	BC,35
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	CALL	_ResetHL
	INC	(IX+-2)
; 1504	                }
L_741:
	LD	B,(IX+-6)
	LD	A,(IX+-2)
	CP	A,B
	JR	C,L_739
	JR	L_768
; 1505	            } else if (stepNumber > 0xFFFFFF - 4) {
L_756:
	LD	BC,(IX+-6)
	LD	HL,16777211
	OR	A,A
	SBC	HL,BC
	JR	NC,L_754
; 1506	                for (a = 0; a < (uint8_t)(0-stepNumber); a++) {
	LD	(IX+-2),0
	JR	L_747
L_745:
; 1507	                    DEC_HL();
	LD	BC,43
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	CALL	_ResetHL
	INC	(IX+-2)
; 1508	                }
L_747:
	LD	HL,(IX+-6)
	CALL	__ineg
	LD	A,(IX+-2)
	CP	A,L
	JR	C,L_745
	JR	L_768
; 1509	            } else {
L_754:
; 1510	                LD_DE_IMM(stepNumber);
	LD	BC,(IX+-6)
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_LoadRegValue
	POP	BC
	POP	BC
; 1511	                ADD_HL_DE();
	LD	BC,25
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	CALL	_ResetHL
	JR	L_768
; 1512	            }
; 1513	        } else {
L_764:
; 1514	            w24(stepExpression + 1, ice.programPtr + PRGM_START - ice.programData + 1);
	LD	BC,13740162
	LD	HL,(_ice+60)
	ADD	HL,BC
	OR	A,A
	LD	BC,(_ice+54)
	SBC	HL,BC
	INC	HL
	LD	IY,(IX+-28)
	LD	(IY+1),HL
; 1515	            ice.ForLoopSMCStack[ice.ForLoopSMCElements++] = (uint24_t*)(endPointExpressionValue + 1);
	LD	DE,(IX+-14)
; 1516	
; 1517	            LD_DE_IMM(0);
	LD	BC,0
	PUSH	BC
	LD	BC,(_ice+3383)
	LD	HL,3
	LD	(IX+-43),HL	; spill
	LD	HL,1
	LD	(IX+-49),HL	; spill
	LD	HL,(IX+-43)	; unspill
	LD	(IX+-43),HL	; spill
	LD	HL,(IX+-49)	; unspill
	PUSH	HL
	LD	HL,(IX+-43)	; unspill
	CALL	__imulu
	INC	DE
	LD	BC,_ice+3083
	ADD	HL,BC
	LD	(HL),DE
	LD	BC,(_ice+3383)
	INC	BC
	LD	(_ice+3383),BC
	CALL	_LoadRegValue
	POP	BC
	POP	BC
; 1518	            ADD_HL_DE();
	LD	BC,25
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	CALL	_ResetHL
; 1519	        }
L_768:
; 1520	        LD_IX_OFF_IND_HL(variable);
	LD	BC,12253
	PUSH	BC
	CALL	_OutputWriteWord
	POP	BC
	LD	C,(IX+-3)
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	A,1
	LD	(_reg+1),A
	LD	A,(IX+-3)
	LD	(_reg+10),A
; 1521	    }
L_771:
; 1522	
; 1523	    smallCode = JumpForward(jumpToCond, ice.programPtr, tempDataOffsetElements, tempGotoElements, tempLblElements);
	LD	C,(IX+-11)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-19)
	PUSH	BC
	LD	BC,(IX+-37)
	PUSH	BC
	LD	BC,(_ice+60)
	PUSH	BC
	LD	BC,(IX+-31)
	PUSH	BC
	CALL	_JumpForward
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-18),A
; 1524	    ResetAllRegs();
	CALL	_ResetAllRegs
; 1525	
; 1526	    // If both the step and the end point are a number, the variable is already in HL
; 1527	    if (!(endPointIsNumber && stepIsNumber)) {
	LD	A,(IX+-10)
	OR	A,A
	JR	Z,L_775
	LD	A,(IX+-7)
	OR	A,A
	JR	NZ,L_799
L_775:
; 1528	        LD_HL_IND_IX_OFF(variable);
	LD	C,(IX+-3)
	LD	B,0
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_LoadRegVariable
	POP	BC
	POP	BC
; 1529	    }
L_799:
; 1530	
; 1531	    if (endPointIsNumber) {
	LD	A,(IX+-10)
	OR	A,A
	JR	Z,L_798
; 1532	        if (stepNumber < 0x800000) {
	LD	BC,8388608
	LD	HL,(IX+-6)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_782
; 1533	            LD_DE_IMM(endPointNumber + 1);
	LD	BC,(IX+-17)
	INC	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_LoadRegValue
	POP	BC
	POP	BC
	JR	L_785
; 1534	        } else {
L_782:
; 1535	            LD_DE_IMM(endPointNumber);
	LD	BC,(IX+-17)
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_LoadRegValue
	POP	BC
	POP	BC
; 1536	            reversedCond = true;
	LD	(IX+-9),1
; 1537	        }
L_785:
; 1538	        OR_A_A();
	LD	BC,183
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	JR	L_802
; 1539	    } else {
L_798:
; 1540	        w24(endPointExpressionValue + 1, ice.programPtr + PRGM_START - ice.programData + 1);
	LD	BC,(IX+-14)
	INC	BC
	LD	(IX+-40),BC
	LD	HL,(_ice+60)
	LD	BC,13740162
	ADD	HL,BC
	OR	A,A
	LD	BC,(_ice+54)
	SBC	HL,BC
	INC	HL
	LD	IY,(IX+-40)
	LD	(IY),HL
; 1541	        ice.ForLoopSMCStack[ice.ForLoopSMCElements++] = (uint24_t*)(endPointExpressionValue + 1);
	LD	DE,(IX+-40)
; 1542	
; 1543	        LD_DE_IMM(0);
	LD	BC,0
	PUSH	BC
	LD	BC,(_ice+3383)
	LD	HL,3
	LD	(IX+-43),HL	; spill
	LD	HL,1
	LD	(IX+-46),HL	; spill
	LD	HL,(IX+-43)	; unspill
	LD	(IX+-43),HL	; spill
	LD	HL,(IX+-46)	; unspill
	PUSH	HL
	LD	HL,(IX+-43)	; unspill
	CALL	__imulu
	LD	BC,_ice+3083
	ADD	HL,BC
	LD	(HL),DE
	LD	BC,(_ice+3383)
	INC	BC
	LD	(_ice+3383),BC
	CALL	_LoadRegValue
	POP	BC
	POP	BC
; 1544	        if (stepNumber < 0x800000) {
	LD	HL,(IX+-6)
	LD	BC,8388608
	OR	A,A
	SBC	HL,BC
	JR	NC,L_795
; 1545	            SCF();
	LD	BC,55
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	JR	L_802
; 1546	        } else {
L_795:
; 1547	            OR_A_A();
	LD	BC,183
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
; 1548	            reversedCond = true;
	LD	(IX+-9),1
; 1549	        }
; 1550	    }
L_802:
; 1551	    SBC_HL_DE();
	LD	BC,21229
	PUSH	BC
	CALL	_OutputWriteWord
	POP	BC
	CALL	_ResetHL
; 1552	
; 1553	    // Jump back to the loop
; 1554	    JumpBackwards(loopStart - (smallCode ? 2 : 0), OP_JR_C - (reversedCond ? 8 : 0));
	LD	A,(IX+-18)
	OR	A,A
	JR	Z,L_805
	LD	BC,2
	LD	(IX+-25),BC
	JR	L_806
L_805:
	LD	BC,0
	LD	(IX+-25),BC
L_806:
	LD	A,(IX+-9)
	OR	A,A
	JR	Z,L_809
	LD	BC,8
	LD	(IX+-22),BC
	JR	L_810
L_809:
	LD	BC,0
	LD	(IX+-22),BC
L_810:
	LD	B,(IX+-22)
	LD	A,56
	SUB	A,B
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-25)
	LD	HL,(IX+-34)
	OR	A,A
	SBC	HL,BC
	PUSH	HL
	CALL	_JumpBackwards
	POP	BC
	POP	BC
; 1555	
; 1556	    return VALID;
	LD	A,255
; 1557	}
L_812:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionFor ***************************
;Name                         Addr/Register   Size   Type
;_JumpBackwards                      IMPORT  -----   function
;_JumpForward                        IMPORT  -----   function
;_LoadRegValue                       IMPORT  -----   function
;_ResetHL                            IMPORT  -----   function
;_LoadRegVariable                    IMPORT  -----   function
;_parseProgramUntilEnd               IMPORT  -----   function
;_ResetAllRegs                       IMPORT  -----   function
;_OutputWriteLong                    IMPORT  -----   function
;_AnsToHL                            IMPORT  -----   function
;_reg                                IMPORT     28   variable
;_OutputWriteByte                    IMPORT  -----   function
;_OutputWriteWord                    IMPORT  -----   function
;_MaybeAToHL                         IMPORT  -----   function
;_expr                               IMPORT     16   variable
;_GetVariableOffset                  IMPORT  -----   function
;_getNextToken                       IMPORT  -----   function
;_ice                                IMPORT  10958   variable
;tempDataOffsetElements               IX-37      3   variable
;loopStart                            IX-34      3   variable
;jumpToCond                           IX-31      3   variable
;stepExpression                       IX-28      3   variable
;temp803                              IX-25      3   variable
;temp807                              IX-22      3   variable
;tempGotoElements                     IX-19      1   variable
;smallCode                            IX-18      1   variable
;endPointNumber                       IX-17      3   variable
;endPointExpressionValue              IX-14      3   variable
;tempLblElements                      IX-11      1   variable
;endPointIsNumber                     IX-10      1   variable
;reversedCond                          IX-9      1   variable
;tok                                   IX-8      1   variable
;stepIsNumber                          IX-7      1   variable
;stepNumber                            IX-6      3   variable
;variable                              IX-3      1   variable
;a                                     IX-2      1   variable
;res                                   IX-1      1   variable
;token                                 IX+6      3   parameter


; Stack Frame Size: 58 (bytes)
;       Spill Code: 0 (instruction)


; 1558	
; 1559	static uint8_t functionPrgm(int token) {
_functionPrgm:
	LD	HL,-7
	CALL	__frameset
; 1560	    uint24_t length;
; 1561	    uint8_t a = 0;
	LD	(IX+-1),0
; 1562	    uint8_t *tempProgramPtr;
; 1563	
; 1564	    MaybeLDIYFlags();
	CALL	_MaybeLDIYFlags
; 1565	    tempProgramPtr = ice.programPtr;
	LD	BC,(_ice+60)
	LD	(IX+-4),BC
; 1566	
; 1567	    OutputWriteByte(TI_PRGM_TYPE);
	LD	BC,5
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
; 1568	
; 1569	    // Fetch the name
; 1570	    while ((token = _getc()) != EOF && (uint8_t)token != tEnter && (uint8_t)token != tColon && ++a < 9) {
	JR	L_816
L_817:
; 1571	        OutputWriteByte(token);
	LD	C,(IX+6)
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
; 1572	    }
L_816:
	CALL	_getNextToken
	LD	(IX+6),HL
	LD	BC,16777215
	OR	A,A
	SBC	HL,BC
	JR	Z,L_818
	LD	A,(IX+6)
	CP	A,63
	JR	Z,L_818
	LD	A,(IX+6)
	CP	A,62
	JR	Z,L_818
	INC	(IX+-1)
	LD	A,(IX+-1)
	CP	A,9
	JR	C,L_817
L_818:
; 1573	    OutputWriteByte(0);
	LD	BC,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
; 1574	
; 1575	    // Check if valid program name
; 1576	    if (!a || a == 9) {
	LD	A,(IX+-1)
	OR	A,A
	JR	Z,L_820
	LD	A,(IX+-1)
	CP	A,9
	JR	NZ,L_821
L_820:
; 1577	        return E_INVALID_PROG;
	LD	A,14
	JR	L_831
; 1578	    }
L_821:
; 1579	
; 1580	    length = ice.programPtr - tempProgramPtr;
	LD	HL,(_ice+60)
	LD	BC,(IX+-4)
	OR	A,A
	SBC	HL,BC
	LD	(IX+-7),HL
; 1581	    ice.programDataPtr -= length;
	LD	HL,(_ice+66)
	LD	BC,(IX+-7)
	OR	A,A
	SBC	HL,BC
	LD	(_ice+66),HL
; 1582	    memcpy(ice.programDataPtr, tempProgramPtr, length);
	LD	BC,(IX+-7)
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	LD	BC,(_ice+66)
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
; 1583	    ice.programPtr = tempProgramPtr;
	LD	BC,(IX+-4)
	LD	(_ice+60),BC
; 1584	
; 1585	    ProgramPtrToOffsetStack();
	CALL	_ProgramPtrToOffsetStack
; 1586	    LD_HL_IMM((uint24_t)ice.programDataPtr);
	LD	BC,(_ice+66)
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_LoadRegValue
	POP	BC
	POP	BC
; 1587	
; 1588	    // Insert the routine to run it
; 1589	    CALL(_Mov9ToOP1);
	LD	BC,205
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	BC,131872
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
; 1590	    LD_HL_IMM(tempProgramPtr - ice.programData + PRGM_START + 28);
	LD	HL,(IX+-4)
	LD	BC,(_ice+54)
	OR	A,A
	SBC	HL,BC
	LD	BC,13740190
	ADD	HL,BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	CALL	_LoadRegValue
	POP	BC
	POP	BC
; 1591	    memcpy(ice.programPtr, PrgmData, 20);
	LD	BC,20
	PUSH	BC
	LD	BC,_PrgmData
	PUSH	BC
	LD	BC,(_ice+60)
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
; 1592	    ice.programPtr += 20;
	LD	IY,(_ice+60)
	LEA	BC,IY+20
	LD	(_ice+60),BC
; 1593	    ResetAllRegs();
	CALL	_ResetAllRegs
; 1594	
; 1595	    return VALID;
	LD	A,255
; 1596	}
L_831:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionPrgm ***************************
;Name                         Addr/Register   Size   Type
;_ResetAllRegs                       IMPORT  -----   function
;_PrgmData                           IMPORT  -----   function
;_OutputWriteLong                    IMPORT  -----   function
;_LoadRegValue                       IMPORT  -----   function
;_ProgramPtrToOffsetStack            IMPORT  -----   function
;_memcpy                             IMPORT  -----   function
;_getNextToken                       IMPORT  -----   function
;_OutputWriteByte                    IMPORT  -----   function
;_ice                                IMPORT  10958   variable
;_MaybeLDIYFlags                     IMPORT  -----   function
;length                                IX-7      3   variable
;tempProgramPtr                        IX-4      3   variable
;a                                     IX-1      1   variable
;token                                 IX+6      3   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


; 1597	
; 1598	static uint8_t functionCustom(int token) {
_functionCustom:
	LD	HL,-1
	CALL	__frameset
; 1599	    uint8_t tok = _getc();
	CALL	_getNextToken
	LD	(IX+-1),L
; 1600	
; 1601	    if (tok >= tDefineSprite && tok <= tCompare) {
	LD	A,(IX+-1)
	CP	A,10
	JR	C,L_839
	LD	A,19
	CP	A,(IX+-1)
	JR	C,L_839
; 1602	        // Call
; 1603	        if (tok == tCall) {
	LD	A,(IX+-1)
	CP	A,11
	JR	NZ,L_837
; 1604	            insertGotoLabel();
	CALL	_insertGotoLabel
; 1605	            CALL(0);
	LD	BC,205
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	BC,0
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
; 1606	
; 1607	            return VALID;
	LD	A,255
	JR	L_840
; 1608	        } else {
L_837:
; 1609	            SeekMinus1();
	CALL	_SeekMinus1
; 1610	
; 1611	            return parseExpression(token);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_parseExpression
	POP	BC
	JR	L_840
; 1612	        }
; 1613	    } else {
L_839:
; 1614	        return E_UNIMPLEMENTED;
	XOR	A,A
; 1615	    }
; 1616	}
L_840:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionCustom ***************************
;Name                         Addr/Register   Size   Type
;_SeekMinus1                         IMPORT  -----   function
;_OutputWriteLong                    IMPORT  -----   function
;_OutputWriteByte                    IMPORT  -----   function
;_insertGotoLabel                    IMPORT  -----   function
;_getNextToken                       IMPORT  -----   function
;tok                                   IX-1      1   variable
;token                                 IX+6      3   parameter


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


; 1617	
; 1618	static uint8_t functionLbl(int token) {
_functionLbl:
	LD	HL,-4
	CALL	__frameset
; 1619	    // Add the label to the stack, and skip the line
; 1620	    label_t *labelCurr = &ice.LblStack[ice.curLbl++];
	LD	DE,(_ice+10895)
	INC	DE
	LD	BC,(_ice+10895)
	LD	(_ice+10895),DE
	LD	HL,26
	CALL	__imulu
	LD	BC,(_ice+71)
	ADD	HL,BC
	LD	(IX+-4),HL
; 1621	    uint8_t a = 0;
	LD	(IX+-1),0
; 1622	    
; 1623	    // Get the label name
; 1624	    while ((token = _getc()) != EOF && (uint8_t)token != tEnter && (uint8_t)token != tColon && a < 20) {
	JR	L_846
L_847:
; 1625	        labelCurr->name[a++] = token;
	LD	D,(IX+6)
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	IY,(IX+-4)
	LEA	HL,IY+0
	ADD	HL,BC
	LD	(HL),D
	INC	(IX+-1)
; 1626	    }
L_846:
	CALL	_getNextToken
	LD	(IX+6),HL
	LD	BC,16777215
	OR	A,A
	SBC	HL,BC
	JR	Z,L_848
	LD	A,(IX+6)
	CP	A,63
	JR	Z,L_848
	LD	A,(IX+6)
	CP	A,62
	JR	Z,L_848
	LD	A,(IX+-1)
	CP	A,20
	JR	C,L_847
L_848:
; 1627	    labelCurr->name[a] = 0;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	IY,(IX+-4)
	LEA	HL,IY+0
	ADD	HL,BC
	LD	(HL),0
; 1628	    labelCurr->addr = ice.programPtr;
	LD	BC,(_ice+60)
	LD	(IY+20),BC
; 1629	    ResetAllRegs();
	CALL	_ResetAllRegs
; 1630	
; 1631	    return VALID;
	LD	A,255
; 1632	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionLbl ***************************
;Name                         Addr/Register   Size   Type
;_ResetAllRegs                       IMPORT  -----   function
;_getNextToken                       IMPORT  -----   function
;_ice                                IMPORT  10958   variable
;labelCurr                             IX-4      3   variable
;a                                     IX-1      1   variable
;token                                 IX+6      3   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


; 1633	
; 1634	static uint8_t functionGoto(int token) {
_functionGoto:
	CALL	__frameset0
; 1635	    insertGotoLabel();
	CALL	_insertGotoLabel
; 1636	    JP(0);
	LD	BC,195
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	BC,0
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
; 1637	
; 1638	    return VALID;
	LD	A,255
; 1639	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionGoto ***************************
;Name                         Addr/Register   Size   Type
;_OutputWriteLong                    IMPORT  -----   function
;_OutputWriteByte                    IMPORT  -----   function
;_insertGotoLabel                    IMPORT  -----   function
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


; 1640	
; 1641	void insertGotoLabel(void) {
_insertGotoLabel:
	LD	HL,-7
	CALL	__frameset
; 1642	    // Add the label to the stack, and skip the line
; 1643	    label_t *gotoCurr = &ice.GotoStack[ice.curGoto++];
	LD	DE,(_ice+10898)
	INC	DE
	LD	BC,(_ice+10898)
	LD	(_ice+10898),DE
	LD	HL,26
	CALL	__imulu
	LD	BC,(_ice+74)
	ADD	HL,BC
	LD	(IX+-4),HL
; 1644	    uint8_t a = 0;
	LD	(IX+-1),0
; 1645	    int token;
; 1646	    
; 1647	    while ((token = _getc()) != EOF && (uint8_t)token != tEnter && (uint8_t)token != tColon && a < 20) {
	JR	L_859
L_860:
; 1648	        gotoCurr->name[a++] = token;
	LD	D,(IX+-7)
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	IY,(IX+-4)
	LEA	HL,IY+0
	ADD	HL,BC
	LD	(HL),D
	INC	(IX+-1)
; 1649	    }
L_859:
	CALL	_getNextToken
	LD	(IX+-7),HL
	LD	BC,16777215
	OR	A,A
	SBC	HL,BC
	JR	Z,L_861
	LD	A,(IX+-7)
	CP	A,63
	JR	Z,L_861
	LD	A,(IX+-7)
	CP	A,62
	JR	Z,L_861
	LD	A,(IX+-1)
	CP	A,20
	JR	C,L_860
L_861:
; 1650	    gotoCurr->name[a] = 0;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	IY,(IX+-4)
	LEA	HL,IY+0
	ADD	HL,BC
	LD	(HL),0
; 1651	    gotoCurr->addr = ice.programPtr;
	LD	BC,(_ice+60)
	LD	(IY+20),BC
; 1652	    gotoCurr->offset = _tell(ice.inPrgm);
	LD	A,(_ice+10904)
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_ti_Tell
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	LD	IY,(IX+-4)
	LD	(IY+23),HL
; 1653	    ResetAllRegs();
	CALL	_ResetAllRegs
; 1654	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _insertGotoLabel ***************************
;Name                         Addr/Register   Size   Type
;_ResetAllRegs                       IMPORT  -----   function
;_ti_Tell                            IMPORT  -----   function
;_getNextToken                       IMPORT  -----   function
;_ice                                IMPORT  10958   variable
;token                                 IX-7      3   variable
;gotoCurr                              IX-4      3   variable
;a                                     IX-1      1   variable


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


; 1655	
; 1656	static uint8_t functionPause(int token) {
_functionPause:
	LD	HL,-1
	CALL	__frameset
; 1657	    if (CheckEOL()) {
	CALL	_CheckEOL
	OR	A,A
	JR	Z,L_875
; 1658	        MaybeLDIYFlags();
	CALL	_MaybeLDIYFlags
; 1659	        CALL(_GetCSC);
	LD	BC,205
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	BC,131404
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
; 1660	        CP_A(9);
	LD	BC,254
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	BC,9
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
; 1661	        JR_NZ(-8);
	LD	BC,32
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	BC,248
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
; 1662	        reg.HLIsNumber = reg.HLIsVariable = false;
	XOR	A,A
	LD	(_reg+1),A
	LD	(_reg),A
; 1663	        reg.AIsNumber = true;
	LD	A,1
	LD	(_reg+6),A
; 1664	        reg.AIsVariable = false;
	XOR	A,A
	LD	(_reg+7),A
; 1665	        reg.AValue = 9;
	LD	A,9
	LD	(_reg+13),A
; 1666	    } else {
	JR	L_876
L_875:
; 1667	        uint8_t res;
; 1668	
; 1669	        SeekMinus1();
	CALL	_SeekMinus1
; 1670	        if ((res = parseExpression(_getc())) != VALID) {
	CALL	_getNextToken
	PUSH	HL
	CALL	_parseExpression
	POP	BC
	LD	(IX+-1),A
	CP	A,255
	JR	Z,L_873
; 1671	            return res;
	LD	A,(IX+-1)
	JR	L_877
; 1672	        }
L_873:
; 1673	        AnsToHL();
	CALL	_AnsToHL
; 1674	
; 1675	        CallRoutine(&ice.usedAlreadyPause, &ice.PauseAddr, (uint8_t*)PauseData, SIZEOF_PAUSE_DATA);
	LD	BC,20
	PUSH	BC
	LD	BC,_PauseData
	PUSH	BC
	LD	BC,_ice+10931
	PUSH	BC
	LD	BC,_ice+10930
	PUSH	BC
	CALL	_CallRoutine
	POP	BC
	POP	BC
	POP	BC
	POP	BC
; 1676	        reg.HLIsNumber = reg.DEIsNumber = true;
	LD	A,1
	LD	(_reg+2),A
	LD	(_reg),A
; 1677	        reg.HLIsVariable = reg.DEIsVariable = false;
	XOR	A,A
	LD	(_reg+3),A
	LD	(_reg+1),A
; 1678	        reg.HLValue = reg.DEValue = -1;
	LD	BC,16777215
	LD	(_reg+19),BC
	LD	(_reg+16),BC
; 1679	        ResetBC();
	CALL	_ResetBC
; 1680	    }
L_876:
; 1681	
; 1682	    return VALID;
	LD	A,255
; 1683	}
L_877:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionPause ***************************
;Name                         Addr/Register   Size   Type
;_ResetBC                            IMPORT  -----   function
;_ice                                IMPORT  10958   variable
;_PauseData                          IMPORT  -----   function
;_CallRoutine                        IMPORT  -----   function
;_AnsToHL                            IMPORT  -----   function
;_getNextToken                       IMPORT  -----   function
;_SeekMinus1                         IMPORT  -----   function
;_reg                                IMPORT     28   variable
;_OutputWriteLong                    IMPORT  -----   function
;_OutputWriteByte                    IMPORT  -----   function
;_MaybeLDIYFlags                     IMPORT  -----   function
;_CheckEOL                           IMPORT  -----   function
;res                                   IX-1      1   variable
;token                                 IX+6      3   parameter


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


; 1684	
; 1685	static uint8_t functionInput(int token) {
_functionInput:
	LD	HL,-1
	CALL	__frameset
; 1686	    uint8_t res;
; 1687	
; 1688	    expr.inFunction = true;
	LD	A,1
	LD	(_expr+1),A
; 1689	    if ((res = parseExpression(_getc())) != VALID) {
	CALL	_getNextToken
	PUSH	HL
	CALL	_parseExpression
	POP	BC
	LD	(IX+-1),A
	CP	A,255
	JR	Z,L_888
; 1690	        return res;
	LD	A,(IX+-1)
	JR	L_901
; 1691	    }
L_888:
; 1692	
; 1693	    if (ice.tempToken == tComma && expr.outputIsString) {
	LD	A,(_ice+69)
	CP	A,43
	JR	NZ,L_887
	LD	A,(_expr+4)
	OR	A,A
	JR	Z,L_887
; 1694	        expr.inFunction = true;
	LD	A,1
	LD	(_expr+1),A
; 1695	        if ((res = parseExpression(_getc())) != VALID) {
	CALL	_getNextToken
	PUSH	HL
	CALL	_parseExpression
	POP	BC
	LD	(IX+-1),A
	CP	A,255
	JR	Z,L_881
; 1696	            return res;
	LD	A,(IX+-1)
	JR	L_901
; 1697	        }
L_881:
; 1698	        *(ice.programPtr - 3) = 0x3E;
	LD	IY,(_ice+60)
	LEA	HL,IY+-3
	LD	(HL),62
; 1699	        *(ice.programPtr - 2) = *(ice.programPtr - 1);
	LD	IY,(_ice+60)
	LEA	HL,IY+-1
	LD	IY,(_ice+60)
	LD	A,(HL)
	LD	(IY+-2),A
; 1700	        ice.programPtr--;
	LD	IY,(_ice+60)
	LEA	BC,IY+-1
	LD	(_ice+60),BC
; 1701	    } else {
	JR	L_891
L_887:
; 1702	        *(ice.programPtr - 3) = 0x3E;
	LD	IY,(_ice+60)
	LEA	HL,IY+-3
	LD	(HL),62
; 1703	        *(ice.programPtr - 2) = *(ice.programPtr - 1);
	LD	IY,(_ice+60)
	LEA	HL,IY+-1
	LD	IY,(_ice+60)
; 1704	        ice.programPtr--;
; 1705	
; 1706	        // FF0000 reads all zeroes, and that's important
; 1707	        LD_HL_IMM(0xFF0000);
	LD	BC,16711680
	PUSH	BC
	LD	A,(HL)
	LD	BC,0
	PUSH	BC
	LD	(IY+-2),A
	LD	IY,(_ice+60)
	LEA	BC,IY+-1
	LD	(_ice+60),BC
	CALL	_LoadRegValue
	POP	BC
	POP	BC
; 1708	    }
L_891:
; 1709	
; 1710	    if (ice.tempToken != tEnter || !expr.outputIsVariable) {
	LD	A,(_ice+69)
	CP	A,63
	JR	NZ,L_890
	LD	A,(_expr+3)
	OR	A,A
	JR	NZ,L_892
L_890:
; 1711	        return E_SYNTAX;
	LD	A,6
	JR	L_901
; 1712	    }
L_892:
; 1713	
; 1714	    MaybeLDIYFlags();
	CALL	_MaybeLDIYFlags
; 1715	
; 1716	    // Copy the Input routine to the data section
; 1717	    if (!ice.usedAlreadyInput) {
	LD	A,(_ice+10926)
	OR	A,A
	JR	NZ,L_894
; 1718	        ice.programDataPtr -= SIZEOF_INPUT_DATA;
	LD	IY,(_ice+66)
	LEA	BC,IY+-96
	LD	(_ice+66),BC
; 1719	        ice.InputAddr = (uintptr_t)ice.programDataPtr;
; 1720	        memcpy(ice.programDataPtr, (uint8_t*)InputData, SIZEOF_INPUT_DATA);
	LD	DE,96
	PUSH	DE
	LD	(_ice+10927),BC
	LD	BC,_InputData
	PUSH	BC
	LD	BC,(_ice+66)
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
; 1721	        ice.usedAlreadyInput = true;
	LD	A,1
	LD	(_ice+10926),A
; 1722	    }
L_894:
; 1723	
; 1724	    // Set which var we need to store to
; 1725	    ProgramPtrToOffsetStack();
	CALL	_ProgramPtrToOffsetStack
; 1726	    LD_ADDR_A(ice.InputAddr + SIZEOF_INPUT_DATA - 5);
	LD	BC,50
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	IY,(_ice+10927)
	LEA	BC,IY+91
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
; 1727	
; 1728	    // Call the right routine
; 1729	    ProgramPtrToOffsetStack();
	CALL	_ProgramPtrToOffsetStack
; 1730	    CALL(ice.InputAddr);
	LD	BC,205
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	LD	BC,(_ice+10927)
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
; 1731	    ResetAllRegs();
	CALL	_ResetAllRegs
; 1732	
; 1733	    return VALID;
	LD	A,255
; 1734	}
L_901:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionInput ***************************
;Name                         Addr/Register   Size   Type
;_ResetAllRegs                       IMPORT  -----   function
;_OutputWriteLong                    IMPORT  -----   function
;_OutputWriteByte                    IMPORT  -----   function
;_ProgramPtrToOffsetStack            IMPORT  -----   function
;_InputData                          IMPORT  -----   function
;_memcpy                             IMPORT  -----   function
;_MaybeLDIYFlags                     IMPORT  -----   function
;_LoadRegValue                       IMPORT  -----   function
;_ice                                IMPORT  10958   variable
;_getNextToken                       IMPORT  -----   function
;_expr                               IMPORT     16   variable
;res                                   IX-1      1   variable
;token                                 IX+6      3   parameter


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


; 1735	
; 1736	static uint8_t functionBB(int token) {
_functionBB:
	LD	HL,-45
	CALL	__frameset
; 1737	    // Asm(
; 1738	    if ((uint8_t)(token = _getc()) == tAsm) {
	CALL	_getNextToken
	LD	(IX+6),HL
	LD	A,(IX+6)
	CP	A,106
	JR	Z,L_908
	JR	L_924
; 1739	        while ((token = _getc()) != EOF && (uint8_t)token != tEnter && (uint8_t)token != tColon && (uint8_t)token != tRParen) {
L_909:
; 1740	            uint8_t tok1, tok2;
; 1741	
; 1742	            // Get hexadecimals
; 1743	            if ((tok1 = IsHexadecimal(token)) == 16 || (tok2 = IsHexadecimal(_getc())) == 16) {
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_IsHexadecimal
	POP	BC
	LD	(IX+-5),A
	CP	A,16
	JR	Z,L_906
	CALL	_getNextToken
	PUSH	HL
	CALL	_IsHexadecimal
	POP	BC
	LD	(IX+-6),A
	CP	A,16
	JR	NZ,L_907
L_906:
; 1744	                return E_INVALID_HEX;
	LD	A,8
	JR	L_925
; 1745	            }
L_907:
; 1746	
; 1747	            OutputWriteByte((tok1 << 4) + tok2);
	LD	A,(IX+-5)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,(IX+-6)
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
; 1748	        }
L_908:
	CALL	_getNextToken
	LD	(IX+6),HL
	LD	BC,16777215
	OR	A,A
	SBC	HL,BC
	JR	Z,L_912
	LD	A,(IX+6)
	CP	A,63
	JR	Z,L_912
	LD	A,(IX+6)
	CP	A,62
	JR	Z,L_912
	LD	A,(IX+6)
	CP	A,17
	JR	NZ,L_909
L_912:
; 1749	        if ((uint8_t)token == tRParen) {
	LD	A,(IX+6)
	CP	A,17
	JR	NZ,L_913
; 1750	            if (!CheckEOL()) {
	CALL	_CheckEOL
	OR	A,A
	JR	NZ,L_913
; 1751	                return E_SYNTAX;
	LD	A,6
	JR	L_925
; 1752	            }
; 1753	        }
L_913:
; 1754	
; 1755	        ResetAllRegs();
	CALL	_ResetAllRegs
; 1756	
; 1757	        return VALID;
	LD	A,255
	JR	L_925
; 1758	    }
; 1759	
; 1760	    // AsmComp(
; 1761	    else if ((uint8_t)token == tAsmComp) {
L_924:
	LD	A,(IX+6)
	CP	A,107
	JR	NZ,L_922
; 1762	        uint8_t res = VALID;
	LD	(IX+-1),255
; 1763	        uint24_t currentLine = ice.currentLine;
	LD	BC,(_ice+3386)
	LD	(IX+-10),BC
; 1764	        ti_var_t tempProg = ice.inPrgm;
	LD	A,(_ice+10904)
	LD	(IX+-7),A
; 1765	        prog_t *outputPrgm;
; 1766	        
; 1767	        outputPrgm = GetProgramName();
	CALL	_GetProgramName
	LD	(IX+-4),HL
; 1768	        if ((res = outputPrgm->errorCode) != VALID) {
	LD	IY,(IX+-4)
	LD	A,(IY+0)
	LD	(IX+-1),A
	CP	A,255
	JR	Z,L_919
; 1769	            free(outputPrgm);
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_free
	POP	BC
; 1770	            return res;
	LD	A,(IX+-1)
	JR	L_925
; 1771	        }
L_919:
; 1772	
; 1773	#ifndef CALCULATOR
; 1774	        char *inName = str_dupcat(outputPrgm->prog, ".8xp");
; 1775	        free(outputPrgm);
; 1776	        if ((ice.inPrgm = _open(inName))) {
; 1777	            int tempProgSize = ice.programLength;
; 1778	            
; 1779	            fseek(ice.inPrgm, 0, SEEK_END);
; 1780	            ice.programLength = ftell(ice.inPrgm);
; 1781	            _rewind(ice.inPrgm);
; 1782	            fprintf(stdout, "Compiling subprogram %s\n", inName);
; 1783	            free(inName);
; 1784	            fprintf(stdout, "Program size: %u\n", ice.programLength);
; 1785	
; 1786	            // Compile it, and close
; 1787	            ice.currentLine = 0;
; 1788	            if ((res = parseProgramUntilEnd()) != VALID) {
; 1789	                return res;
; 1790	            }
; 1791	            fprintf(stdout, "Return from subprogram...\n");
; 1792	            fclose(ice.inPrgm);
; 1793	            ice.currentLine = currentLine;
; 1794	            ice.programLength = tempProgSize;
; 1795	        } else {
; 1796	            free(inName);
; 1797	            res = E_PROG_NOT_FOUND;
; 1798	        }
; 1799	#else
; 1800	        if ((ice.inPrgm = _open(outputPrgm->prog))) {
	LD	BC,5
	PUSH	BC
	LD	BC,L__365
	PUSH	BC
	LD	IY,(IX+-4)
	PEA	IY+1
	CALL	_ti_OpenVar
	POP	BC
	POP	BC
	POP	BC
	LD	(_ice+10904),A
	OR	A,A
	JR	Z,L_918
; 1801	            char buf[35];
; 1802	
; 1803	            displayLoadingBarFrame();
	CALL	_displayLoadingBarFrame
; 1804	            sprintf(buf, "Compiling subprogram %s...", outputPrgm->prog);
	LD	IY,(IX+-4)
	PEA	IY+1
	LD	BC,L__367
	PUSH	BC
	PEA	IX+-45
	CALL	_sprintf
	POP	BC
	POP	BC
	POP	BC
; 1805	            displayMessageLineScroll(buf);
	PEA	IX+-45
	CALL	_displayMessageLineScroll
	POP	BC
; 1806	            strcpy(ice.currProgName[ice.inPrgm], outputPrgm->prog);
	LD	A,(_ice+10904)
	UEXT	HL
	LD	L,A
	LD	A,9
	CALL	__imul_b
	LD	IY,(IX+-4)
	PEA	IY+1
	LD	BC,_ice+9
	ADD	HL,BC
	PUSH	HL
	CALL	_strcpy
	POP	BC
	POP	BC
; 1807	            free(outputPrgm);
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_free
	POP	BC
; 1808	
; 1809	            // Compile it, and close
; 1810	            ice.currentLine = 0;
	LD	BC,0
	LD	(_ice+3386),BC
; 1811	            if ((res = parseProgramUntilEnd()) != VALID) {
	CALL	_parseProgramUntilEnd
	LD	(IX+-1),A
	CP	A,255
	JR	Z,L_916
; 1812	                return res;
	LD	A,(IX+-1)
	JR	L_925
; 1813	            }
L_916:
; 1814	            ti_Close(ice.inPrgm);
	LD	A,(_ice+10904)
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_ti_Close
	POP	BC
; 1815	
; 1816	            displayLoadingBarFrame();
	CALL	_displayLoadingBarFrame
; 1817	            displayMessageLineScroll("Return from subprogram...");
	LD	BC,L__369
	PUSH	BC
	CALL	_displayMessageLineScroll
	POP	BC
; 1818	            ice.currentLine = currentLine;
	LD	BC,(IX+-10)
	LD	(_ice+3386),BC
; 1819	        } else {
	JR	L_920
L_918:
; 1820	            free(outputPrgm);
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_free
	POP	BC
; 1821	            res = E_PROG_NOT_FOUND;
	LD	(IX+-1),12
; 1822	        }
L_920:
; 1823	#endif
; 1824	        ice.inPrgm = tempProg;
	LD	A,(IX+-7)
	LD	(_ice+10904),A
; 1825	
; 1826	        return res;
	LD	A,(IX+-1)
	JR	L_925
; 1827	    } else {
L_922:
; 1828	        SeekMinus1();
	CALL	_SeekMinus1
; 1829	        
; 1830	        return parseExpression(t2ByteTok);
	LD	BC,187
	PUSH	BC
	CALL	_parseExpression
	POP	BC
; 1831	    }
; 1832	}
L_925:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _functionBB ***************************
;Name                         Addr/Register   Size   Type
;_SeekMinus1                         IMPORT  -----   function
;_ti_Close                           IMPORT  -----   function
;_parseProgramUntilEnd               IMPORT  -----   function
;_strcpy                             IMPORT  -----   function
;_displayMessageLineScroll           IMPORT  -----   function
;_sprintf                            IMPORT  -----   function
;_displayLoadingBarFrame             IMPORT  -----   function
;_ti_OpenVar                         IMPORT  -----   function
;_free                               IMPORT  -----   function
;_GetProgramName                     IMPORT  -----   function
;_ice                                IMPORT  10958   variable
;_ResetAllRegs                       IMPORT  -----   function
;_CheckEOL                           IMPORT  -----   function
;_OutputWriteByte                    IMPORT  -----   function
;_IsHexadecimal                      IMPORT  -----   function
;_getNextToken                       IMPORT  -----   function
;buf                                  IX-45     35   variable
;currentLine                          IX-10      3   variable
;tempProg                              IX-7      1   variable
;tok2                                  IX-6      1   variable
;tok1                                  IX-5      1   variable
;outputPrgm                            IX-4      3   variable
;res                                   IX-1      1   variable
;token                                 IX+6      3   parameter


; Stack Frame Size: 54 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__365:
	DB	"r"
	DB	0
L__367:
	DB	"Compiling subprogram %s..."
	DB	0
L__369:
	DB	"Return from subprogram..."
	DB	0
	SEGMENT CODE
; 1833	
; 1834	static uint8_t tokenWrongPlace(int token) {
_tokenWrongPlace:
	CALL	__frameset0
; 1835	    return E_WRONG_PLACE;
	LD	A,1
; 1836	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _tokenWrongPlace ***************************
;Name                         Addr/Register   Size   Type
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


; 1837	
; 1838	static uint8_t tokenUnimplemented(int token) {
_tokenUnimplemented:
	CALL	__frameset0
; 1839	    return E_UNIMPLEMENTED;
	XOR	A,A
; 1840	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _tokenUnimplemented ***************************
;Name                         Addr/Register   Size   Type
;token                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


; 1841	
; 1842	void optimizeZeroCarryFlagOutput(void) {
_optimizeZeroCarryFlagOutput:
; 1843	    if (!expr.AnsSetZeroFlag && !expr.AnsSetCarryFlag && !expr.AnsSetZeroFlagReversed && !expr.AnsSetCarryFlagReversed) {
	LD	A,(_expr+5)
	OR	A,A
	JR	NZ,L_947
	LD	A,(_expr+7)
	OR	A,A
	JR	NZ,L_947
	LD	A,(_expr+6)
	OR	A,A
	JR	NZ,L_947
	LD	A,(_expr+8)
	OR	A,A
	JR	NZ,L_947
; 1844	        if (expr.outputRegister == REGISTER_HL) {
	LD	A,(_expr+10)
	OR	A,A
	JR	NZ,L_945
; 1845	            ADD_HL_DE();
	LD	BC,25
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	CALL	_ResetHL
; 1846	            OR_A_SBC_HL_DE();
	LD	BC,5434807
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
	CALL	_ResetHL
; 1847	            expr.AnsSetZeroFlag = true;
	LD	A,1
	LD	(_expr+5),A
; 1848	        } else if (expr.outputRegister == REGISTER_DE) {
	JR	L_948
L_945:
	LD	A,(_expr+10)
	CP	A,1
	JR	NZ,L_943
; 1849	            OutputWrite3Bytes(OP_SCF, 0xED, 0x62);
	LD	BC,6483255
	PUSH	BC
	CALL	_OutputWriteLong
	POP	BC
; 1850	            ADD_HL_DE();
	LD	BC,25
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	CALL	_ResetHL
; 1851	            expr.AnsSetCarryFlagReversed = true;
	LD	A,1
	LD	(_expr+8),A
; 1852	        } else {
	JR	L_948
L_943:
; 1853	            OR_A_A();
	LD	BC,183
	PUSH	BC
	CALL	_OutputWriteByte
	POP	BC
	JR	L_948
; 1854	        }
; 1855	    } else {
L_947:
; 1856	        ice.programPtr -= expr.ZeroCarryFlagRemoveAmountOfBytes;
	LD	A,(_expr+9)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(_ice+60)
	OR	A,A
	SBC	HL,BC
	LD	(_ice+60),HL
; 1857	    }
L_948:
; 1858	    return;
; 1859	}
	RET	


;**************************** _optimizeZeroCarryFlagOutput ***************************
;Name                         Addr/Register   Size   Type
;_ice                                IMPORT  10958   variable
;_OutputWriteLong                    IMPORT  -----   function
;_ResetHL                            IMPORT  -----   function
;_OutputWriteByte                    IMPORT  -----   function
;_expr                               IMPORT     16   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


; 1860	
; 1861	void skipLine(void) {
_skipLine:
; 1862	    while (!CheckEOL());
L_951:
	CALL	_CheckEOL
	OR	A,A
	JR	Z,L_951
; 1863	}
	RET	


;**************************** _skipLine ***************************
;Name                         Addr/Register   Size   Type
;_CheckEOL                           IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT DATA
_functions:
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenWrongPlace
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_functionI
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_tokenWrongPlace
	DW24	_tokenWrongPlace
	DW24	_dummyReturn
	DW24	_dummyReturn
	DW24	_tokenWrongPlace
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_functionPrgm
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_functionCustom
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenWrongPlace
	DW24	_tokenWrongPlace
	DW24	_tokenWrongPlace
	DW24	_tokenWrongPlace
	DW24	_tokenWrongPlace
	DW24	_tokenWrongPlace
	DW24	_tokenWrongPlace
	DW24	_tokenWrongPlace
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_tokenWrongPlace
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_functionBB
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_functionIf
	DW24	_tokenUnimplemented
	DW24	_functionElse
	DW24	_functionWhile
	DW24	_functionRepeat
	DW24	_functionFor
	DW24	_functionEnd
	DW24	_functionReturn
	DW24	_functionLbl
	DW24	_functionGoto
	DW24	_functionPause
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_functionInput
	DW24	_tokenUnimplemented
	DW24	_functionDisp
	DW24	_tokenUnimplemented
	DW24	_functionOutput
	DW24	_functionClrHome
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_parseExpression
	DW24	_parseExpression
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	DW24	_tokenUnimplemented
	XREF _implementedFunctions:ROM
	XREF _grabString:ROM
	XREF _getNextToken:ROM
	XREF _CheckEOL:ROM
	XREF _GetVariableOffset:ROM
	XREF _IsHexadecimal:ROM
	XREF _CallRoutine:ROM
	XREF _MaybeLDIYFlags:ROM
	XREF _MaybeAToHL:ROM
	XREF _displayMessageLineScroll:ROM
	XREF _AnsToHL:ROM
	XREF _PushHLDE:ROM
	XREF _ResetA:ROM
	XREF _ResetBC:ROM
	XREF _ResetHL:ROM
	XREF _ResetAllRegs:ROM
	XREF _LoadRegVariable:ROM
	XREF _LoadRegValue:ROM
	XREF _displayLoadingBar:ROM
	XREF _SeekMinus1:ROM
	XREF _GetProgramName:ROM
	XREF _displayLoadingBarFrame:ROM
	XREF _ProgramPtrToOffsetStack:ROM
	XREF _IsA2ByteTok:ROM
	XREF _OutputWriteLong:ROM
	XREF _OutputWriteWord:ROM
	XREF _OutputWriteByte:ROM
	XREF _GetIndexOfFunction:ROM
	XREF _setStackValues:ROM
	XREF _removeIndexFromStack:ROM
	XREF _getIndexOffset:ROM
	XREF _getCurrentIndex:ROM
	XREF _getNextIndex:ROM
	XREF _push:ROM
	XREF _displayError:ROM
	XREF _displayLabelError:ROM
	XREF _parseFunction:ROM
	XREF _PauseData:ROM
	XREF _DispData:ROM
	XREF _PrgmData:ROM
	XREF _InputData:ROM
	XREF _RandData:ROM
	XREF _reg:ROM
	XREF _prescan:ROM
	XREF _expr:ROM
	XREF _ice:ROM
	XREF _operatorPrecedence2:ROM
	XREF _operatorPrecedence:ROM
	XREF _parseOperator:ROM
	XREF _LD_HL_STRING:ROM
	XREF _executeOperator:ROM
	XREF _getIndexOfOperator:ROM
	XREF _strlen:ROM
	XREF _strcpy:ROM
	XREF _memcmp:ROM
	XREF _memmove:ROM
	XREF _memset:ROM
	XREF _memcpy:ROM
	XREF _sprintf:ROM
	XREF _ti_Tell:ROM
	XREF _ti_Rewind:ROM
	XREF _ti_Seek:ROM
	XREF _ti_PutC:ROM
	XREF _ti_Write:ROM
	XREF _ti_Close:ROM
	XREF _ti_OpenVar:ROM
	XREF _ti_Open:ROM
	XREF _free:ROM
	XREF _sqrt:ROM
	XREF _sin:ROM
	XREF _cos:ROM
	XREF __indcall:ROM
	XREF __ladd:ROM
	XREF __ldivs:ROM
	XREF __imuls:ROM
	XREF __imulu:ROM
	XREF __ineg:ROM
	XREF __iand:ROM
	XREF __iremu:ROM
	XREF __ishru:ROM
	XREF __ishl:ROM
	XREF __fmul:ROM
	XREF __ftol:ROM
	XREF __ultof:ROM
	XREF __stoiu:ROM
	XREF __frameset0:ROM
	XREF __frameset:ROM
	XREF __setflag:ROM
	XREF __scmpzero:ROM
	XREF __icmpzero:ROM
	XREF __case8:ROM
	XREF __imul_b:ROM
	XREF __ishl_b:ROM
	XDEF _skipLine
	XDEF _optimizeZeroCarryFlagOutput
	XDEF _insertGotoLabel
	XDEF _functionRepeat
	XDEF _WhileJumpBackwardsLarge
	XDEF _WhileRepeatCondStart
	XDEF _JumpBackwards
	XDEF _JumpForward
	XDEF _parsePostFixFromIndexToIndex
	XDEF _parseExpression
	XDEF _parseProgramUntilEnd
	XDEF _parseProgram
	XDEF _stack
	XDEF _outputStack
; 1864	
; 1865	static uint8_t (*functions[256])(int) = {
	END
